<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Python on SoftLayer API Examples </title>
    <link>https://softlayer.github.io/python/</link>
    <language>en-US</language>
    <author>Enthusiastic Hugo User</author>
    <rights>Copyright (c) 2014, Enthusiastic Hugo User; all rights reserved.</rights>
    <updated>Wed, 13 Sep 2017 00:00:00 UTC</updated>
    
    <item>
      <title>Advanced Bare Metal Server Ordering</title>
      <link>https://softlayer.github.io/python/orderbaremetal/</link>
      <pubDate>Wed, 13 Sep 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/orderbaremetal/</guid>
      <description>

&lt;p&gt;Example of how to build an order for a bare metal server.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Find the package that you want to order. listServerPackages() will filter out all that are not bare metal servers&lt;/li&gt;
&lt;li&gt;Use getServerPrices() to find the item keyNames you want to include in your order. These price IDs can be included prices array directly, but I&amp;rsquo;ve included gatherPriceIds() to match up KeyNames to build a list of price ids. getServerPrices() will also show the locations available for ordering.&lt;/li&gt;
&lt;li&gt;listAvailableVlans() if you want to place the server on a specific VLAN.&lt;/li&gt;
&lt;li&gt;listPartitionTemplates() will show what partition schemes you can apply to a disk.&lt;/li&gt;
&lt;li&gt;listRaidArrayTypes() shows what id numbers are for each RAID type.&lt;/li&gt;
&lt;li&gt;Custom partitions can ONLY be specified for CentOS or RHEL servers, and ONLY on the secondary drives &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Trying to do the same for the primary controller will result in the default partitinoTemplate being applied. Custom partitions also require the arraySize be declared.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
@author Christopher Gallo
Places an order for a Bare Metal Server
&amp;quot;&amp;quot;&amp;quot;
import SoftLayer
from pprint import pprint as pp



class ordering():

    def __init__(self):

        self.client = SoftLayer.Client()

    def main(self, package_id, location_id, pub_vlan_id=&#39;&#39;, priv_vlan_id=&#39;&#39;):
        &amp;quot;&amp;quot;&amp;quot;
        Places an order for a Bare Metal Instance
        &amp;quot;&amp;quot;&amp;quot;

        &amp;quot;&amp;quot;&amp;quot;These items are required for all servers and have a 0$ cost, some can be upgraded&amp;quot;&amp;quot;&amp;quot;
        required_items = [
            &#39;AUTOMATED_NOTIFICATION&#39;,
            &#39;MONITORING_HOST_PING&#39;,
            &#39;NOTIFICATION_EMAIL_AND_TICKET&#39;,
            &#39;REBOOT_KVM_OVER_IP&#39;,
            &#39;NESSUS_VULNERABILITY_ASSESSMENT_REPORTING&#39;,
            &#39;UNLIMITED_SSL_VPN_USERS_1_PPTP_VPN_USER_PER_ACCOUNT&#39;,
            &#39;REDUNDANT_POWER_SUPPLY&#39;,
        ]
        &amp;quot;&amp;quot;&amp;quot;We need bandwidth, at least 1 ip, and the port speed &amp;quot;&amp;quot;&amp;quot;
        network_items = [
            &#39;BANDWIDTH_500_GB&#39;,
            &#39;1_IP_ADDRESS&#39;,
            &#39;1_GBPS_DUAL_PUBLIC_PRIVATE_NETWORK_UPLINKS_UNBONDED&#39;,
        ]
        &amp;quot;&amp;quot;&amp;quot;A disk controller, a duplicate entry for each disk you want, in order, ram, OS and processor chip &amp;quot;&amp;quot;&amp;quot;
        physical_items = [
            &#39;DISK_CONTROLLER_RAID&#39;,
            &#39;HARD_DRIVE_2_00_TB_SATA_2&#39;,
            &#39;HARD_DRIVE_2_00_TB_SATA_2&#39;,
            &#39;HARD_DRIVE_2_00_TB_SATA_2&#39;,
            &#39;HARD_DRIVE_2_00_TB_SATA_2&#39;,
            &#39;RAM_128_GB_DDR3_1333_REG_2&#39;,
            &#39;OS_VSPHERE_ENTERPRISE_PLUS_6_0&#39;,
            &#39;INTEL_XEON_2620_2_00&#39;
        ]

        all_items = required_items + network_items + physical_items
        prices = self.gatherPriceIds(package_id, all_items)
        productOrder = {&#39;orderContainers&#39;: [
                {&#39;hardware&#39;: 
                    [
                        {
                            &#39;domain&#39;: u&#39;cgallo.com&#39;,
                            &#39;hostname&#39;: u&#39;vmware-testing01&#39;,
                            &#39;primaryBackendNetworkComponent&#39;: {&#39;networkVlan&#39;: {&#39;id&#39; : int(priv_vlan_id)}},
                            &#39;primaryNetworkComponent&#39;: {&#39;networkVlan&#39;: {&#39;id&#39; : int(priv_vlan_id)}}
                        }
                    ],
                    &#39;location&#39;: location_id,
                    &#39;packageId&#39;: package_id,
                    &#39;prices&#39;: prices,
                    &#39;quantity&#39;: 1,
                    &#39;storageGroups&#39; : [
                        {
                            &#39;arrayTypeId&#39;: 2,
                            &#39;hardDrives&#39;: [0,1],
                            &#39;partitionTemplateId&#39; : 1
                        },
                        {
                            &#39;arrayTypeId&#39;: 9,
                            &#39;arraySize&#39; : 2000,
                            &#39;hardDrives&#39;: [2],
                            &#39;partitions&#39; : [
                                {&#39;name&#39; : &#39;/&#39;, &#39;size&#39;: 200, &#39;isGrow&#39;: 0},
                                {&#39;name&#39; : &#39;/boot&#39;, &#39;size&#39;: 100},
                                {&#39;name&#39; : &#39;/usr&#39;, &#39;size&#39;: 200},
                                {&#39;name&#39; : &#39;/mine&#39;, &#39;size&#39;: 200},
                                {&#39;name&#39; : &#39;/media&#39;, &#39;size&#39;: 1, &#39;isGrow&#39;: 1},
                            ]

                        },
                        {
                            &#39;arrayTypeId&#39;: 9,
                            &#39;hardDrives&#39;: [3]
                        }
                    ],
                }
            ]
        }
        pp(productOrder)
        order = self.client[&#39;Product_Order&#39;].verifyOrder(productOrder)
        # order = self.client[&#39;Product_Order&#39;].placeOrder(productOrder)
        pp(order)


    def listServerPackages(self):
        mask = &amp;quot;mask[type]&amp;quot;
        _filter = {
            &#39;type&#39;: {
                &#39;keyName&#39;: {&#39;operation&#39;: &#39;BARE_METAL_CPU&#39;},
            },
        }
        result = self.client[&#39;Product_Package&#39;].getAllObjects(mask=mask, filter=_filter)

        for product in result:
            print(&amp;quot;%s - %s - %s - %s&amp;quot; % 
                (product[&#39;id&#39;],
                 product[&#39;name&#39;],
                 product[&#39;keyName&#39;],
                 product[&#39;type&#39;][&#39;keyName&#39;])
            )
            

    def listPartitionTemplates(self):
        mask = &amp;quot;mask[partitionTemplates[data]]&amp;quot;
        result = self.client[&#39;SoftLayer_Hardware_Component_Partition_OperatingSystem&#39;].getAllObjects(mask=mask)
        print(&amp;quot;OS Type, Notes&amp;quot;)
        for os_type in result:
            print(&amp;quot;%s - %s&amp;quot; % (os_type[&#39;description&#39;],os_type[&#39;notes&#39;]))
            print(&amp;quot;\tTemplate id, Description&amp;quot;)
            for template in os_type[&#39;partitionTemplates&#39;]:
                print(&amp;quot;\t%s - %s &amp;quot; % (template[&#39;id&#39;],template[&#39;description&#39;]))
                for partition in template[&#39;data&#39;]:
                    print(&amp;quot;\t\t%s - %s %s&amp;quot; % 
                        (partition[&#39;partitionName&#39;], 
                         partition[&#39;partitionSize&#39;], 
                         &#39;Grow&#39; if partition[&#39;isGrow&#39;] else &#39;&#39;)
                    )

    def listRaidArrayTypes(self):
        result = self.client[&#39;SoftLayer_Configuration_Storage_Group_Array_Type&#39;].getAllObjects()
        for raid in result:
            print(&amp;quot;%s - %s - %s Min:%s Max:%s&amp;quot; % 
                (raid[&#39;id&#39;], 
                 raid[&#39;keyName&#39;], 
                 raid[&#39;description&#39;], 
                 raid[&#39;minimumDrives&#39;], 
                 raid[&#39;maximumDrives&#39;])
            ) 

    def listAvailableVlans(self, dc_id):
        mask = &amp;quot;mask[network,type,primaryRouter[datacenter]]&amp;quot;
        _filter = {
            &#39;networkVlans&#39; : {
                &#39;primaryRouter&#39;: {
                    &#39;datacenter&#39; : { &#39;id&#39;: {&#39;operation&#39;: dc_id} }
                }
            }
        }
        result = self.client[&#39;SoftLayer_Account&#39;].getNetworkVlans(mask=mask,filter=_filter)
        for vlan in result:
            print(&amp;quot;%s - VLAN: %s - Type: %s - %s &amp;quot; % 
                (vlan[&#39;id&#39;], 
                 vlan[&#39;vlanNumber&#39;],
                 vlan[&#39;type&#39;][&#39;keyName&#39;], 
                 vlan[&#39;primaryRouter&#39;][&#39;hostname&#39;])
            )

    def getServerPrices(self, package_id):
        mask = &amp;quot;mask[regions,items[prices],activeServerItems[prices]]&amp;quot;
        # locations = self.client[&#39;Product_Package&#39;].getLocations(id=package_id)
        result = self.client[&#39;Product_Package&#39;].getObject(mask=mask,id=package_id)
        print(&amp;quot;Location ID, Location Name&amp;quot;)
        for location in result[&#39;regions&#39;]:
            print(&amp;quot;%s - %s &amp;quot; % (location[&#39;location&#39;][&#39;location&#39;][&#39;id&#39;],location[&#39;description&#39;]))
        print(&amp;quot;Price ID, description, Monthly Fee, KeyName&amp;quot;)
        for item in result[&#39;items&#39;]:
            for prices in item[&#39;prices&#39;]:
                # only print the Default location price. 
                # The ordering system will replace the default price id for you if ordering in a non-usa region.
                if prices[&#39;locationGroupId&#39;] is &#39;&#39;:
                    # Some software has core restrictions that effect prices
                    if &#39;capacityRestrictionType&#39; in prices:
                        cores = &amp;quot;%s - %s&amp;quot; % (
                             prices[&#39;capacityRestrictionMinimum&#39;], 
                             prices[&#39;capacityRestrictionMaximum&#39;])
                        print(&amp;quot;%s, %s - %s cores, $%s, %s &amp;quot; % 
                            (prices[&#39;id&#39;],
                             item[&#39;description&#39;],
                             cores,prices.get(&#39;recurringFee&#39;,&#39;?&#39;),
                             item[&#39;keyName&#39;])
                        )
                    else:
                        print(&amp;quot;%s, %s, $%s, %s &amp;quot; % 
                            (prices[&#39;id&#39;],
                              item[&#39;description&#39;],
                              prices.get(&#39;recurringFee&#39;,&#39;?&#39;),
                              item[&#39;keyName&#39;])
                        )
        print(&amp;quot;======= SERVER ITEMS =======&amp;quot;)
        # serverItems = self.client[&#39;Product_Package&#39;].getActiveServerItems(id=package_id)
        print(&amp;quot;Price ID, description, Monthly Fee, KeyName&amp;quot;)
        for item in result[&#39;activeServerItems&#39;]:
            for prices in item[&#39;prices&#39;]:
                # only print the Default location price. 
                # The ordering system will replace the default price id for you if ordering in a non-usa region.
                if prices[&#39;locationGroupId&#39;] is &#39;&#39;:
                    print(&amp;quot;%s, %s, $%s, %s &amp;quot; % 
                        (prices[&#39;id&#39;],
                         item[&#39;description&#39;],
                         prices.get(&#39;recurringFee&#39;,&#39;?&#39;),
                         item[&#39;keyName&#39;])
                    )


    def gatherPriceIds(self,package_id,keyNames):
        # This wont work for prices that have core requirements
        mask = &amp;quot;mask[items[prices],activeServerItems[prices]]&amp;quot;
        items = self.client[&#39;Product_Package&#39;].getObject(mask=mask,id=package_id)

        prices = []
        sorted_items = {}

        for item in items[&#39;items&#39;]:
            for price in item[&#39;prices&#39;]:
                if price[&#39;locationGroupId&#39;] is &#39;&#39;: 
                    sorted_items[item[&#39;keyName&#39;]] = price[&#39;id&#39;]
        for item in items[&#39;activeServerItems&#39;]:
            for price in item[&#39;prices&#39;]:
                if price[&#39;locationGroupId&#39;] is &#39;&#39;: 
                    sorted_items[item[&#39;keyName&#39;]] = price[&#39;id&#39;]

        for keyName in keyNames:
            prices.append({&#39;id&#39;: int(sorted_items.get(keyName))})
        return prices

if __name__ == &amp;quot;__main__&amp;quot;:

    main = ordering()

    &amp;quot;&amp;quot;&amp;quot;
    Step 1, find the processor type you want
    269 - Quad E7-4800  Series (6 Drives) - 2U_QUAD_E74800_6_DRIVES : BARE_METAL_CPU
    &amp;quot;&amp;quot;&amp;quot;
    main.listServerPackages()
    package_id = 263

    &amp;quot;&amp;quot;&amp;quot;
    Step 2, collect all the pieces you want to order
    getServerPrices will list out all the keyNames and cost of components
    that can be ordered on a certain package. Will also list the DCs that this
    server is available in.
    &amp;quot;&amp;quot;&amp;quot;
    main.getServerPrices(package_id)
    location_id = 142776

    &amp;quot;&amp;quot;&amp;quot;
    Step 3, customize and place the order
    &amp;quot;&amp;quot;&amp;quot;
    main.listAvailableVlans(location_id)
    pub_vlan_id  = 2137279
    priv_vlan_id = 2137281
    main.listPartitionTemplates()
    main.listRaidArrayTypes()
    main.main(package_id,location_id,pub_vlan_id,priv_vlan_id)

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;exceptions-you-might-see&#34;&gt;Exceptions you might see&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SoftLayerAPIError(SoftLayer_Exception_Order_InvalidStorageGroups):&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Defining partitions on secondary storage groups is only allowed for CentOS and Red Hat operating systems.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Chose the right operating system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;SoftLayerAPIError(SoftLayer_Exception_Order_InvalidLocation):&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;The location provided for this order is invalid.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Choose a correct location, locations should be displayed in getServerPrices()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;SoftLayerAPIError(SoftLayer_Exception_Order_InvalidStorageGroups):&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Storage group #1 does not have a grow partition. Each storage group with partitions defined must have a grow partition.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Make sure your partition has &amp;lsquo;isGrow&amp;rsquo; = 1 at some point.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;SoftLayerAPIError(SoftLayer_Exception_Order_InvalidStorageGroups):&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Storage group #1 with size (GB) is smaller than the total partitioned size (501GB).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You forgot to assign an arraySize.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;a href=&#34;https://sldn.softlayer.com/reference/datatypes/SoftLayer_Container_Product_Order_Storage_Group&#34;&gt;https://sldn.softlayer.com/reference/datatypes/SoftLayer_Container_Product_Order_Storage_Group&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Object Storage Uploader</title>
      <link>https://softlayer.github.io/python/swiftuploader/</link>
      <pubDate>Wed, 13 Sep 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/swiftuploader/</guid>
      <description>

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;We’ve recently added the option to import customer-supplied Virtual Hard Disks (VHDs) to our object storage offering. This is a great option for our customers who may have special virtual machines that they have spent hours perfecting. Since learning to import these images can pose a slight challenge, especially for those unfamiliar with object storage (OpenStack Swift), I wrote this blog to share scripts that will streamline the process.&lt;/p&gt;

&lt;h2 id=&#34;object-storage&#34;&gt;Object Storage&lt;/h2&gt;

&lt;p&gt;SoftLayer’s object storage is an enhanced version of OpenStack Swift. Although we’ve added features to it, the API (on the whole) is still the same. Two requirements of particular importance to storing disk images are limitations and requirements on large files. Swift limits all files to be 5GB or less. To support larger files users need to create a manifest file that combines smaller files into one large file.&lt;/p&gt;

&lt;p&gt;For example, to upload a 12GB VHD, the user is expected to segment the file into at least three files and then create a manifest that brings them back together.&lt;/p&gt;

&lt;h2 id=&#34;easier-importing&#34;&gt;Easier Importing&lt;/h2&gt;

&lt;p&gt;Since many people don’t have the time to learn the inner workings of Swift and would just like to get VHDs running on their servers, I have created a set scripts to simplify the process. They handle the authentication, file segmentation, and dynamic manifest creation for you, so you can get up and running quickly. You can easily access them here .&lt;/p&gt;

&lt;p&gt;You can use a Bash script or a Python 3 script. Both do the same thing, but depending on your environment you may prefer one over the other.&lt;/p&gt;

&lt;p&gt;But before we jump into the scripts, you’ll need to find your object storage username and password.&lt;/p&gt;

&lt;p&gt;To get those, log in to &lt;a href=&#34;http://control.softlayer.com&#34;&gt;http://control.softlayer.com&lt;/a&gt;, go to Storage-&amp;gt;Object Storage, select your cluster (I would suggest Dallas 5 for your first tests), and then click “View Credentials” in the top left of the page. You will be presented with a modal window containing your username and API Key (or password) for object storage.&lt;/p&gt;

&lt;h2 id=&#34;objectstorageuploader-sh-bash-edition&#34;&gt;ObjectStorageUploader.sh - Bash Edition&lt;/h2&gt;

&lt;p&gt;The idea behind this script is to have as little user interaction as possible. By calling the script with the proper parameters, you are able to walk away and let it do its thing.&lt;/p&gt;

&lt;p&gt;Simply place the bash script in your directory of VHDs. Call the script by passing in the image you want to upload, the location to upload it (container/filename), and your Swift username and password.&lt;/p&gt;

&lt;p&gt;$ ./ObjectStorageUpload.sh myOS.vhd &amp;lsquo;myContainer/myOS.vhd&amp;rsquo; &amp;lsquo;SLOS1234-1:SL1234&amp;rsquo; &amp;lsquo;apikey&amp;rsquo;&lt;/p&gt;

&lt;p&gt;It will begin the process of walking through the segments of the file and building up your object in object storage.&lt;/p&gt;

&lt;h2 id=&#34;objectstorageuploader-py-python-3-edition&#34;&gt;ObjectStorageUploader.py - Python 3 Edition&lt;/h2&gt;

&lt;p&gt;Before we begin, make sure you have installed the latest version of Python 3 located here: &lt;a href=&#34;https://www.python.org/downloads/&#34;&gt;https://www.python.org/downloads/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Any Python 3 release will work, but I have been using Python 3.4.0 for my testing.&lt;/p&gt;

&lt;p&gt;The idea behind this script is to actually walk you through the process of uploading a file to Swift. Use this script via supplied parameters, in “interactive mode,” or a combination of the two. This is particularly handy for Windows users who are newer to scripting. Simply drop the script in the folder containing your VHDs, run it, and let it guide you through uploading the image to object storage.&lt;/p&gt;

&lt;p&gt;To execute the script, place it in the directory where you store your VHDs and double click it. It will then prompt you to select the file you want to upload.&lt;/p&gt;

&lt;p&gt;After selecting your file, you will be asked for your Swift username and password. Authentication will be attempted and, if successful, the list of containers in your cluster will be presented.&lt;/p&gt;

&lt;p&gt;Select the container you want to upload to and the script will begin uploading the VHD to object storage.&lt;/p&gt;

&lt;p&gt;If you prefer the command line arguments approach, you can pass in arguments to this script too. The signature is slightly different since all the opinions are optional.&lt;/p&gt;

&lt;p&gt;$ python ObjectStorageUpload.py -f myOS.vhd -t &amp;lsquo;myContainer/myOS.vhd&amp;rsquo; -u &amp;lsquo;SLOS1234-1:SL1234&amp;rsquo;&lt;/p&gt;

&lt;h2 id=&#34;importing-uploaded-vhd-as-image-templates&#34;&gt;Importing Uploaded VHD as Image Templates&lt;/h2&gt;

&lt;p&gt;Now that your image is in object storage you can import your VHD into the SoftLayer template, so you can use it to provision a new virtual server!&lt;/p&gt;

&lt;p&gt;Go to your image templates page in the portal and click the “Import Image” tab. Select the Swift account, cluster, container, and file that you uploaded. Give your new template a name and some notes. Make sure to fill out the Operating System information properly as this is used when setting up your new server, and finally click “Import.”&lt;/p&gt;

&lt;p&gt;Lastly, you will be emailed after the VHD has been processed by our system.&lt;/p&gt;

&lt;p&gt;-Adam Shaw&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# ================================================================================
#     ObjectStorageUploader.py
#     © Copyright IBM Corporation 2014.
#     LICENSE: MIT (http://opensource.org/licenses/MIT)    
# ================================================================================

import argparse
import os
import math
import http.client
from urllib.parse import urlparse
from urllib.parse import quote


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(&amp;quot;-f&amp;quot;, &amp;quot;--file&amp;quot;, help=&amp;quot;file to upload to SWIFT&amp;quot;)
    parser.add_argument(&amp;quot;-u&amp;quot;, &amp;quot;--username&amp;quot;, help=&amp;quot;SWIFT username&amp;quot;)
    parser.add_argument(&amp;quot;-p&amp;quot;, &amp;quot;--password&amp;quot;, help=&amp;quot;SWIFT password (SoftLayer API key)&amp;quot;)
    parser.add_argument(&amp;quot;-c&amp;quot;, &amp;quot;--cluster&amp;quot;, help=&amp;quot;SWIFT cluster to use (default: dal05.objectstorage.softlayer.net)&amp;quot;)
    parser.add_argument(&amp;quot;-t&amp;quot;, &amp;quot;--target&amp;quot;, help=&amp;quot;location on SWIFT cluster to store file (container/filename.vhd)&amp;quot;)
    args = parser.parse_args()

    if not args.file:
        filename = select_file()
    else:
        filename = args.file

    if not args.username:
        swift_user_name, swift_password = get_swift_credentials()
    else:
        swift_user_name = args.username
        swift_password = args.password

    if not args.cluster:
        storage_url, auth_token = authenticate_swift(
            swift_user_name,
            swift_password,
            &amp;quot;dal05.objectstorage.softlayer.net&amp;quot;
        )
    else:
        storage_url, auth_token = authenticate_swift(
            swift_user_name,
            swift_password,
            args.cluster
        )

    if not args.target:
        container = select_container(storage_url, auth_token)
        swift_target_path = &amp;quot;{}/{}&amp;quot;.format(container, quote(filename))
    else:
        swift_target_path = args.target

    upload_file(filename, swift_target_path, storage_url, auth_token)


def select_file():
    current_path = (os.path.dirname(os.path.realpath(__file__)))
    print(&amp;quot;Files in {}&amp;quot;.format(current_path))
    files = get_file_list(current_path)
    return prompt_for_choice(files, &amp;quot;Select file for upload:&amp;quot;)


def get_file_list(path):
    files = []
    for file in os.listdir(path):
        if os.path.isfile(file):
            files.append(file)
    return files


def prompt_for_choice(list, prompt_label):
    for i, item in enumerate(list):
        if len(item):
            print(&amp;quot;{}) {}&amp;quot;.format(i, item))
    selected_index = input(prompt_label)
    if selected_index.isdigit():
        if 0 &amp;lt;= int(selected_index) &amp;lt; len(list):
            print()
            return list[int(selected_index)]

    print(&amp;quot;Invalid Input: {}&amp;quot;.format(selected_index))
    return prompt_for_choice(list, prompt_label)


def get_swift_credentials():
    swift_user_name = input(&amp;quot;Swift Username:&amp;quot;)
    swift_password = input(&amp;quot;Swift Password:&amp;quot;)
    return swift_user_name, swift_password


def authenticate_swift(swift_user_name, swift_password, selected_endpoint=&amp;quot;&amp;quot;):
    if selected_endpoint == &amp;quot;&amp;quot;:
        swift_endpoints = [
            &amp;quot;dal05.objectstorage.softlayer.net&amp;quot;,
            &amp;quot;sng01.objectstorage.softlayer.net&amp;quot;,
            &amp;quot;ams01.objectstorage.softlayer.net&amp;quot;,
        ]
        selected_endpoint = prompt_for_choice(
            swift_endpoints,
            &amp;quot;Select Object Storage Endpoint:&amp;quot;
        )

    print(&amp;quot;Authenticating...&amp;quot;)
    headers = {
        &amp;quot;X-Storage-User&amp;quot;: swift_user_name,
        &amp;quot;X-Storage-Pass&amp;quot;: swift_password
    }
    try:
        response = object_storage_request(
            selected_endpoint,
            &amp;quot;/auth/v1.0/&amp;quot;,
            headers
        )
    except Exception:
        swift_user_name, swift_password = get_swift_credentials()
        return authenticate_swift(swift_user_name, swift_password)
    print(&amp;quot;Success!&amp;quot;)

    storage_url = response.getheader(&amp;quot;X-Storage-Url&amp;quot;)
    auth_token = response.getheader(&amp;quot;X-Auth-Token&amp;quot;)

    return storage_url, auth_token


def select_container(storage_url, auth_token):
    url_tuple = urlparse(storage_url)

    headers = {&amp;quot;X-Auth-Token&amp;quot;: auth_token}
    try:
        response = object_storage_request(
            url_tuple.netloc,
            url_tuple.path,
            headers
        )
    except Exception:
        swift_user_name, swift_password = get_swift_credentials()
        storage_url, auth_token = authenticate_swift(swift_user_name, swift_password)
        return select_container(storage_url, auth_token)

    containers = response.read().decode(&amp;quot;utf-8&amp;quot;).split(&amp;quot;\n&amp;quot;)
    return prompt_for_choice(containers, &amp;quot;Select Container:&amp;quot;)


def object_storage_request(server, path, headers, method=&amp;quot;GET&amp;quot;, data=&amp;quot;&amp;quot;):
    connection = http.client.HTTPConnection(server)
    connection.request(method, path, data, headers)
    response = connection.getresponse()

    if 200 &amp;lt;= response.getcode() &amp;lt; 300:
        return response

    print(&amp;quot;Error {}: {}&amp;quot;.format(response.status, response.reason))
    raise Exception(response.status, response.reason)


def upload_file(filename, swift_target_path, storage_url, auth_token):
    url_tuple = urlparse(storage_url)
    headers = {&amp;quot;X-Auth-Token&amp;quot;: auth_token}

    file_size = os.path.getsize(filename)
    block_size = 1048576
    chunk_size = 5 * block_size
    chunks = math.ceil(file_size / chunk_size)

    print(&amp;quot;Reading in file&amp;quot;)
    file = open(filename, &#39;rb&#39;)
    print(&amp;quot;Uploading {} to \&amp;quot;{}\&amp;quot;&amp;quot;.format(filename, swift_target_path))
    for i in range(0, chunks):
        data = file.read(chunk_size)
        print(&amp;quot;Uploading part {} of {}&amp;quot;.format(i + 1, chunks))
        chunk_name = &amp;quot;chunk-{0:0&amp;gt;5}&amp;quot;.format(i)
        object_storage_request(
            url_tuple.netloc,
            &amp;quot;{}/{}/{}&amp;quot;.format(url_tuple.path, swift_target_path, chunk_name),
            headers,
            &amp;quot;PUT&amp;quot;,
            data
        )

    try:
        print(&amp;quot;Writing manifest file&amp;quot;)
        headers = {
            &amp;quot;X-Auth-Token&amp;quot;: auth_token,
            &amp;quot;X-Object-Manifest&amp;quot;: swift_target_path,
            &amp;quot;Content-Length&amp;quot;: 0,
        }
        object_storage_request(
            url_tuple.netloc,
            &amp;quot;{}/{}&amp;quot;.format(url_tuple.path, swift_target_path),
            headers,
            &amp;quot;PUT&amp;quot;
        )
    except Exception:
        return

    print(&amp;quot;File Uploaded!&amp;quot;)

if __name__ == &amp;quot;__main__&amp;quot;:
    main()

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
# ================================================================================
#     ObjectStorageUploader.sh
#     © Copyright IBM Corporation 2014.
#     LICENSE: MIT (http://opensource.org/licenses/MIT)    
# ================================================================================

#./objectstorageupload.sh dsl-4.4.10.iso &#39;myContainer/file.vhd&#39; &#39;SLOS1234-1:SL1234&#39; &#39;apikey&#39;

fileToUpload=$1
swiftTargetPath=$2
swiftUsername=$3
swiftPassword=$4

swiftEndpoint=&#39;https://dal05.objectstorage.softlayer.net/auth/v1.0/&#39;

apiResponse=$(curl -X GET -H &amp;quot;X-Storage-User: $swiftUsername&amp;quot; -H &amp;quot;X-Storage-Pass: $swiftPassword&amp;quot; -s -i $swiftEndpoint)
swiftAuthToken=$(echo &amp;quot;$apiResponse&amp;quot; | grep &amp;quot;X-Auth-Token:&amp;quot; | sed &#39;s/X-Auth-Token: //g&#39; | tr -d &#39;\r&#39;)
swiftStorageUrl=$(echo &amp;quot;$apiResponse&amp;quot; | grep &amp;quot;X-Storage-Url:&amp;quot; | sed &#39;s/X-Storage-Url: //g&#39; | tr -d &#39;\r&#39;)

fileSize=$(wc -c $fileToUpload | awk &#39;{print $1}&#39;)
blockSize=1048576
let chunkSize=2048 #2GB chunks
let chunks=($fileSize/$blockSize+$chunkSize-1)/$chunkSize;

for ((i=0; i&amp;lt;chunks; i++))
do
   printf -v chunkName &amp;quot;chunk-%05d&amp;quot; $i
   let skipChunk=$i*chunkSize

   dd if=$fileToUpload bs=$blockSize count=$chunkSize skip=$skipChunk | curl -X PUT -H &amp;quot;X-Auth-Token: $swiftAuthToken&amp;quot; --data-binary @- &amp;quot;$swiftStorageUrl/$swiftTargetPath/$chunkName&amp;quot;
done

curl -X PUT -H &amp;quot;X-Auth-Token: $swiftAuthToken&amp;quot; -H &amp;quot;X-Object-Manifest: $swiftTargetPath&amp;quot; -H &amp;quot;Content-Length: 0&amp;quot; $swiftStorageUrl/$swiftTargetPath
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Originally from &lt;a href=&#34;https://sldn.softlayer.com/blog/ashaw/object-storage-uploader&#34;&gt;SLDN&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Get Dedicated Host Allocation</title>
      <link>https://softlayer.github.io/python/getdedihostallocation/</link>
      <pubDate>Fri, 04 Aug 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/getdedihostallocation/</guid>
      <description>&lt;p&gt;The first thing you need to get is a list of the Dedicated Hosts on your account. To list the Dedicated Hosts on your account you can use the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import SoftLayer
from pprint import pprint as pp

client = SoftLayer.Client()

dedicatedHosts = client[&#39;SoftLayer_Account&#39;].getDedicatedHosts()
pp(dedicatedHosts)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you have the Dedicated Host ID you can use the following code to retrieve the resource allocations on the host.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
@author Ryan TIffany
&amp;quot;&amp;quot;&amp;quot;
import SoftLayer
from pprint import pprint as pp

dedicatedHostId = 10501
client = SoftLayer.Client()

getAllocStats = client[&#39;SoftLayer_Virtual_DedicatedHost&#39;].getAllocationStatus(id=dedicatedHostId)
pp(getAllocStats)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Get Dedicated Host Guests</title>
      <link>https://softlayer.github.io/python/getdedicatedhostguests/</link>
      <pubDate>Fri, 04 Aug 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/getdedicatedhostguests/</guid>
      <description>&lt;p&gt;The first thing you need to get is a list of the Dedicated Hosts on your account. To list the Dedicated Hosts on your account you can use the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import SoftLayer
from pprint import pprint as pp

client = SoftLayer.Client()

dedicatedHosts = client[&#39;SoftLayer_Account&#39;].getDedicatedHosts()
pp(dedicatedHosts)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you have the Dedicated Host ID you can use the following code to retrieve the Virtual Guests on the host.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&amp;quot;&amp;quot;&amp;quot;
@service SoftLayer_Virtual_DedicatedHost
@author Ryan TIffany
&amp;quot;&amp;quot;&amp;quot;
import SoftLayer
from pprint import pprint as pp

dhId = 10001
client = SoftLayer.Client()
getGuests = client[&#39;SoftLayer_Virtual_DedicatedHost&#39;].getGuests(id=dhId)
pp(getGuests)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Migrate a VSI between dedicated hosts</title>
      <link>https://softlayer.github.io/python/migratededicatedinstance/</link>
      <pubDate>Fri, 04 Aug 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/migratededicatedinstance/</guid>
      <description>&lt;p&gt;The first thing you need to get is a list of the Dedicated Hosts on your account. To list the Dedicated Hosts on your account you can use the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import SoftLayer
from pprint import pprint as pp

client = SoftLayer.Client()

dedicatedHosts = client[&#39;SoftLayer_Account&#39;].getDedicatedHosts()
pp(dedicatedHosts)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you have the Dedicated Host ID you want to migrate the Virtual Guest to you can use this script to kick of an immediate migration of the Virtual Guest.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;
@author Ryan TIffany
&amp;quot;&amp;quot;&amp;quot;
import SoftLayer
from pprint import pprint as pp

destinationHostId = 987654
vsiId = 1234567
client = SoftLayer.Client()

migrateGuest = client[&#39;SoftLayer_Virtual_Guest&#39;].migrateDedicatedHost(destinationHostId, id=vsiId)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Show user accounts with and without two-factor enabled</title>
      <link>https://softlayer.github.io/python/externalbindingusers/</link>
      <pubDate>Fri, 04 Aug 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/externalbindingusers/</guid>
      <description>&lt;p&gt;To get a list of users &lt;em&gt;with&lt;/em&gt; Two-Factor authentication enabled.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;
@author Ryan TIffany
&amp;quot;&amp;quot;&amp;quot;

import SoftLayer
from pprint import pprint as pp 

client = SoftLayer.Client()
mask = mask&amp;quot;[id,username,firstName,lastName,externalBindingCount,externalBindings]&amp;quot;
theFilter = {
&#39;users&#39;: {
	&#39;externalBindings&#39;:{
		&#39;active&#39;:{
			&#39;operation&#39;:&#39;1&#39;
		}}}
}

getUsers = client[&#39;SoftLayer_Account&#39;].getUsers(filter=theFilter, mask=mask)
pp(getUsers)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get a list of users &lt;em&gt;without&lt;/em&gt; Two-Factor authentication enabled.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;
@author Ryan TIffany
&amp;quot;&amp;quot;&amp;quot;

import SoftLayer
from pprint import pprint as pp 

client = SoftLayer.Client()
mask = mask&amp;quot;[id,username,firstName,lastName,externalBindingCount,externalBindings]&amp;quot;
theFilter = {
&#39;users&#39;: {
	&#39;externalBindings&#39;:{
		&#39;active&#39;:{
			&#39;operation&#39;:&#39;0&#39;
		}}}
}

getUsers = client[&#39;SoftLayer_Account&#39;].getUsers(filter=theFilter, mask=mask)
pp(getUsers)

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Router Model Map</title>
      <link>https://softlayer.github.io/python/networkmapper/</link>
      <pubDate>Fri, 23 Jun 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/networkmapper/</guid>
      <description>&lt;p&gt;Prints out model numbers of networking equipment that is on route to your servers. Could be useful if merged with &lt;a href=&#34;https://softlayer.github.io/python/networktopology/&#34;&gt;https://softlayer.github.io/python/networktopology/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;
@author Christopher Gallo
Finds the model number of all networking equipment that is on the way to servers on the account.
&amp;quot;&amp;quot;&amp;quot;
import SoftLayer
from pprint import pprint as pp

class networkMap():

    def __init__(self):

        self.client = SoftLayer.Client()

    def main(self):
        &amp;quot;&amp;quot;&amp;quot;
        Goes through each server, and prints out what networking hardware is upstream
        &amp;quot;&amp;quot;&amp;quot;
        mask = &amp;quot;mask[id, fullyQualifiedDomainName]&amp;quot; 
        servers = self.client[&#39;SoftLayer_Account&#39;].getHardware(mask=mask)
        for server in servers:
            print(&amp;quot;%s&amp;quot; % (server[&#39;fullyQualifiedDomainName&#39;]))
            server_mask = &amp;quot;mask[backendNetworkComponents[networkHardware[hardwareChassis]]]&amp;quot; 
            this_server = self.client[&#39;SoftLayer_Hardware_Server&#39;].getObject(id=server[&#39;id&#39;],mask=server_mask)
            for component in this_server[&#39;backendNetworkComponents&#39;]:
                print(&amp;quot;\t%s%s (%smbps) &amp;quot; % (component[&#39;name&#39;], component[&#39;port&#39;], component[&#39;speed&#39;]))
                for uplink in component[&#39;networkHardware&#39;]:
                    print(&amp;quot;\t\t%s - %s - %s&amp;quot; % (uplink[&#39;fullyQualifiedDomainName&#39;], uplink[&#39;hardwareChassis&#39;][&#39;name&#39;], uplink[&#39;hardwareChassis&#39;][&#39;hardwareFunction&#39;][&#39;description&#39;]))


    def fromTheTop(self):
        &amp;quot;&amp;quot;&amp;quot;
        Goes through each DC, and prints out the hierarchy of networking gear
        &amp;quot;&amp;quot;&amp;quot;
        dc_mask=&amp;quot;mask[backendHardwareRouters]&amp;quot;
        dcs = self.client[&#39;SoftLayer_Location_Datacenter&#39;].getDatacenters()

        for dc in dcs:
            print(&amp;quot;%s&amp;quot; % (dc[&#39;name&#39;]))
            router_mask = &amp;quot;mask[hardwareChassis,downlinkHardware[hardwareChassis,downlinkHardware[hardwareChassis,downstreamServers[id,fullyQualifiedDomainName],id,fullyQualifiedDomainName]]]&amp;quot;
            backend = self.client[&#39;SoftLayer_Location_Datacenter&#39;].getBackendHardwareRouters(id=dc[&#39;id&#39;],mask=router_mask)
            for router in backend:
                print(&amp;quot;\t%s - %s - %s &amp;quot; % (router[&#39;hardwareFunction&#39;][&#39;description&#39;], router[&#39;fullyQualifiedDomainName&#39;], router[&#39;hardwareChassis&#39;][&#39;name&#39;]))
                # Can be used to print out info on the linecards of the BCR/FCR
                # for component in router[&#39;components&#39;]:
                    # print(&amp;quot;\t\t%s&amp;quot; % (component[&#39;hardwareComponentModel&#39;][&#39;longDescription&#39;]))
                try:
                    for down in router[&#39;downlinkHardware&#39;]:
                        print(&amp;quot;\t\t%s - %s &amp;quot; % (down[&#39;fullyQualifiedDomainName&#39;],down[&#39;hardwareChassis&#39;][&#39;name&#39;]))
                        for down_1 in down[&#39;downlinkHardware&#39;]:
                            print(&amp;quot;\t\t\t%s - %s &amp;quot; % (down_1[&#39;fullyQualifiedDomainName&#39;],down_1[&#39;hardwareChassis&#39;][&#39;name&#39;]))
                            for server in down_1[&#39;downstreamServers&#39;]:
                                print(&amp;quot;\t\t\t\t%s&amp;quot; % server[&#39;fullyQualifiedDomainName&#39;])
                except KeyError:
                    print(&amp;quot;Skipping....&amp;quot;)


if __name__ == &amp;quot;__main__&amp;quot;:
    main = networkMap()
    # main.main()
    main.fromTheTop()

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Create a Security group</title>
      <link>https://softlayer.github.io/python/createsecuritygroup/</link>
      <pubDate>Tue, 20 Jun 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/createsecuritygroup/</guid>
      <description>

&lt;p&gt;The Security Group offering is currently in Beta. The use of this feature is restricted to select users. When the Beta period is over, security groups will be available for all users. Contact sgbeta@us.ibm.com using &amp;lsquo;Security Groups&amp;rsquo; in the subject line with any questions.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-security-group&#34;&gt;Creating a Security Group&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import SoftLayer
# For nice debug output:
from pprint import pprint as pp
# Create an object template to create the item.
objectTemplate = {
	&#39;accountId&#39;: YOUR_ACCOUNT_ID,
    &#39;name&#39;: &#39;pythonCreatedGroupExample&#39;,
    &#39;description&#39;: &#39;Sec Group created via python&#39;
} 
client = SoftLayer.Client()
try:
    result = client[&#39;SoftLayer_Network_SecurityGroup&#39;].createObjects([objectTemplate])
    pp(result)
except SoftLayer.SoftLayerAPIError as e:
    pp(&#39;Failed ... Unable to create a new SecGroup  faultCode=%s, faultString=%s&#39;
        % (e.faultCode, e.faultString))

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Provision Times</title>
      <link>https://softlayer.github.io/python/provisiontimes/</link>
      <pubDate>Mon, 12 Jun 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/provisiontimes/</guid>
      <description>&lt;p&gt;Goes through orders and prints out each transaction that provisioned a server or virtual server. Calculates provision time from the time the order was placed, till the time the transaction went to COMPLETE.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Order: 15866609 - 2017-06-09T10:42:04-06:00
    FQDN, Status, transaction id, elapsed time
    sgtest.cdetest.info, COMPLETE, 57090965, 383.0
Order: 15861187 - 2017-06-09T09:07:49-06:00
    FQDN, Status, transaction id, elapsed time
    jumpbox.cdetest.info, COMPLETE, 57080823, 774.0
Order: 15860993 - 2017-06-09T08:53:22-06:00
    FQDN, Status, transaction id, elapsed time
Order: 15853891 - 2017-06-09T04:47:32-06:00
    FQDN, Status, transaction id, elapsed time
    d1.cdetest.info, COMPLETE, 57055133, 2148.0
    d2.cdetest.info, COMPLETE, 57055135, 2159.0
    d3.cdetest.info, COMPLETE, 57055137, 2155.0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
@author Christopher Gallo
&amp;quot;&amp;quot;&amp;quot;
import SoftLayer
from pprint import pprint as pp
from datetime import datetime

class bcolors:
    HEADER = &#39;\033[95m&#39;
    OKBLUE = &#39;\033[94m&#39;
    OKGREEN = &#39;\033[92m&#39;
    WARNING = &#39;\033[93m&#39;
    FAIL = &#39;\033[91m&#39;
    ENDC = &#39;\033[0m&#39;
    BOLD = &#39;\033[1m&#39;
    UNDERLINE = &#39;\033[4m&#39;

class example():

    def __init__(self):

        self.client = SoftLayer.Client()

    def main(self):
        # Accounts with a large number of orders will want to use this filter.
        startDate = &amp;quot;04/01/2017 01:00:00&amp;quot;
        endDate = &amp;quot;06/12/2017 01:00:00&amp;quot;
        theFilter1 = {
            &#39;orders&#39;: {
                &#39;createDate&#39;: {
                    &#39;operation&#39;: &#39;betweenDate&#39;,
                    &#39;options&#39;: [
                        {&#39;name&#39;: &#39;startDate&#39;, &#39;value&#39;: [startDate]},
                        {&#39;name&#39;: &#39;endDate&#39;, &#39;value&#39;: [endDate]}
                    ]
                }
            }
        }
        mask = &amp;quot;mask[items[hostName, domainName, categoryCode, billingItem[id,provisionTransaction]]]&amp;quot;
        items = 10
        offset = 0
        limit = 10
        while items == 10:
            orders = self.client[&#39;SoftLayer_Account&#39;].getOrders(filter=theFilter1, offset=offset, limit=limit, mask=mask)
            items = len(orders)
            offset = offset + limit
            self.printOrderTimes(orders)

    def printOrderTimes(self, orders):
        for order in orders:
            print(&amp;quot;Order: %s - %s &amp;quot; % (order[&#39;id&#39;], order[&#39;createDate&#39;]))
            print(&amp;quot;\tFQDN, Status, transaction id, elapsed time&amp;quot;)
            # pp(order)
            createDate = order[&#39;createDate&#39;]
            timeWarn = 600
            timeRed = 1200
            for item in order[&#39;items&#39;]:
                if item[&#39;categoryCode&#39;] == &#39;server&#39;:
                    # 1 hour
                    timeWarn = 3600
                    # 4 hours 
                    timeRed = 14400
                elif item[&#39;categoryCode&#39;] == &#39;guest_core&#39;:
                    # 10 minutes
                    timeWarn = 600
                    # 20 minutes
                    timeRed = 1200

                if item[&#39;categoryCode&#39;] == &#39;server&#39; or item[&#39;categoryCode&#39;] == &#39;guest_core&#39;:

                    try:
                        transaction = item[&#39;billingItem&#39;][&#39;provisionTransaction&#39;]
                    except KeyError:
                        # Likely a canceled order
                        continue

                    #python timezones are weird and I don&#39;t want to deal with them. 
                    t_s = createDate[:-6] 
                    t_e = transaction[&#39;statusChangeDate&#39;][:-6] 


                    FMT = &#39;%Y-%m-%dT%H:%M:%S&#39;
                    tdelta = datetime.strptime(t_e,FMT) - datetime.strptime(t_s,FMT)
                    fqdn = &amp;quot;%s.%s&amp;quot; % (item[&#39;hostName&#39;], item[&#39;domainName&#39;])
                    seconds =  tdelta.total_seconds()
                    if seconds &amp;gt; timeWarn and seconds &amp;lt; timeRed:
                        color = bcolors.WARNING
                    elif seconds &amp;gt;= timeRed:
                        color = bcolors.FAIL
                    else:
                        color = bcolors.OKGREEN
                    print(&amp;quot;\t%s%s, %s, %s, %s%s&amp;quot; % 
                        (color,fqdn, transaction[&#39;transactionStatus&#39;][&#39;name&#39;], transaction[&#39;id&#39;], seconds ,bcolors.ENDC)
                    )

if __name__ == &amp;quot;__main__&amp;quot;:
    main = example()
    main.main()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Get bills by user</title>
      <link>https://softlayer.github.io/python/billsbyuser/</link>
      <pubDate>Fri, 09 Jun 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/billsbyuser/</guid>
      <description>&lt;p&gt;This is a rough script, it doesn&amp;rsquo;t include some of the tax fees and some of the other one off fee fields that you will find in &lt;a href=&#34;http://sldn.softlayer.com/reference/datatypes/SoftLayer_Billing_Item&#34;&gt;http://sldn.softlayer.com/reference/datatypes/SoftLayer_Billing_Item&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Example Output for billsByUser()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;chris-cde - 840.0
    123.cdetesting.com : Dual Intel Xeon E5-2620 v3 (12 Cores, 2.40 GHz) $345.0
    234.cdetesting.com : Dual Intel Xeon E5-2620 v3 (12 Cores, 2.40 GHz) $495.0
    chris.testing.com : 2 x 2.0 GHz Cores $0.0
    4 Portable Private IP Addresses - $0.0
    8 Portable Private IP Addresses - $0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example Output of upcoming_hourly()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ItemID  Info    Host    Domain  Hours   Hourly Cost Cost
143131173   Dual Intel Xeon E5-2620 v3 (12 Cores, 2.40 GHz) jd-cos-testing-sjc03    secore.com  489 .309    151.101
==&amp;gt; 143131179   64 GB RAM   291.933
==&amp;gt; 143131183   1.00 TB SATA    17.604
==&amp;gt; 143131185   1.00 TB SATA    17.604
==&amp;gt; 143131189   10 Gbps Dual Public &amp;amp; Private Network Uplinks (Unbonded)    147.189
TOTAL: 625.431
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Source&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
@author Christopher Gallo
Goes through the next invoice. Collections billing items by the user that orderd them.
Prints out each user and how much they caused in billing, along with what they ordered.
&amp;quot;&amp;quot;&amp;quot;
import SoftLayer
from pprint import pprint as pp

class bills():

    def __init__(self):

        self.client = SoftLayer.Client()
        self.mgr = SoftLayer.VSManager(self.client)

    def billsByUser(self):

        &amp;quot;&amp;quot;&amp;quot;
        Not all billing items have a user record, these are collected under the master account
        http://sldn.softlayer.com/reference/services/SoftLayer_Account/getNextInvoiceTopLevelBillingItems returns
        http://sldn.softlayer.com/reference/datatypes/SoftLayer_Billing_Item -&amp;gt; taps orderItem for
        http://sldn.softlayer.com/reference/datatypes/SoftLayer_Billing_Order_Item -&amp;gt; taps order for 
        http://sldn.softlayer.com/reference/datatypes/SoftLayer_Billing_Order -&amp;gt; taps userRecord for
        http://sldn.softlayer.com/reference/datatypes/SoftLayer_User_Customer
        &amp;quot;&amp;quot;&amp;quot;
        mask=&amp;quot;mask[orderItem[order[id,userRecord[displayName,username]]]]&amp;quot;
        billingItems = self.client[&#39;SoftLayer_Account&#39;].getNextInvoiceTopLevelBillingItems(mask=mask)

        users = {&#39;masterUser&#39;: []}
        for item in billingItems:
            if &#39;orderItem&#39; in item:
                username = item[&#39;orderItem&#39;][&#39;order&#39;][&#39;userRecord&#39;][&#39;username&#39;]
                del item[&#39;orderItem&#39;]
                if username not in users:
                    users[username] = []
                users[username].append(item)
            else:
                users[&#39;masterUser&#39;].append(item)


        # prints everything out, and finds the sum of items.
        for user in users:
            servers = []
            everything_else = []
            total_cost = 0

            for item in users[user]:

                # this doens&#39;t include Tax fees, or setup fees because I&#39;m lazy
                cost = float(item[&#39;recurringFee&#39;]) + float(item[&#39;oneTimeFee&#39;])
                if &#39;hostName&#39; in item:
                    fqdn = &amp;quot;%s.%s : %s $%s&amp;quot; % (item[&#39;hostName&#39;], item[&#39;domainName&#39;], item[&#39;description&#39;], cost)
                    servers.append(fqdn)
                else:
                    item = &amp;quot;%s - $%s&amp;quot; % (item[&#39;description&#39;], cost)
                    everything_else.append(item)
                total_cost = total_cost + cost
            print(&amp;quot;%s - %s&amp;quot; % (user , total_cost))
            for server in servers:
                print(&amp;quot;\t%s&amp;quot; % server)
            for thing in everything_else:
                print(&amp;quot;\t%s&amp;quot; % thing)


    def upcoming_hourly(self):
    &amp;quot;&amp;quot;&amp;quot;
    Filters upcoming billing items for only hourly WITH a hostname that contains the string &#39;test&#39;
    Each hourly server will also have some children that need to be added for the total cost, those are included with the nonZeroNextInvoiceChildren property
    NOTE: 
    ObjectMask starts at http://sldn.softlayer.com/reference/datatypes/SoftLayer_Billing_item
    ObjectFilter starts at http://sldn.softlayer.com/reference/datatypes/SoftLayer_Account
    hourlyFlag needs to be 1 or 0.

    &amp;quot;&amp;quot;&amp;quot;
        mask=&amp;quot;mask[hourlyFlag,nonZeroNextInvoiceChildren]&amp;quot;
        objectFilter =  {
            &#39;nextInvoiceTopLevelBillingItems&#39;: {
                &#39;hourlyFlag&#39;: {&#39;operation&#39;: 1},
                &#39;hostName&#39;: {&#39;operation&#39;: &#39;*= test&#39;}
            }
        }
        billingItems = self.client[&#39;SoftLayer_Account&#39;].getNextInvoiceTopLevelBillingItems(mask=mask, filter=objectFilter)
        print(&amp;quot;ItemID\tInfo\tHost\tDomain\tHours\tHourly Cost\tCost&amp;quot;)
        for item in billingItems:
            itemId = item[&#39;id&#39;]
            hostName = item[&#39;hostName&#39;]
            domainName = item[&#39;domainName&#39;]
            description = item[&#39;description&#39;]
            hours = item[&#39;hoursUsed&#39;]
            hourly_cost = item[&#39;hourlyRecurringFee&#39;]
            cost = int(hours) * float(hourly_cost)
            total_cost = cost
            print(&amp;quot;%s\t%s\t%s\t%s\t%s\t%s\t%s&amp;quot; % (itemId, description, hostName,domainName, hours, hourly_cost, cost ))
            for child in item[&#39;nonZeroNextInvoiceChildren&#39;]:
                childId = child[&#39;id&#39;]
                childDesc = child[&#39;description&#39;]
                childCost = int(child[&#39;hoursUsed&#39;]) * float(child[&#39;hourlyRecurringFee&#39;])
                total_cost = total_cost + childCost
                print(&amp;quot;==&amp;gt; %s\t%s\t%s&amp;quot; % (childId,childDesc,childCost))
            print(&amp;quot;TOTAL: %s&amp;quot; % (total_cost))


if __name__ == &amp;quot;__main__&amp;quot;:
    main = bills()
    main.billsByUser()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Tag Vlans</title>
      <link>https://softlayer.github.io/python/vlantagging/</link>
      <pubDate>Fri, 09 Jun 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/vlantagging/</guid>
      <description>&lt;p&gt;A rough examples of how to add vlans to servers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
@author Christopher Gallo


@sldn{SoftLayer_Network_Component}
@sldn{SoftLayer_Network_Component,getNetworkVlanTrunks}

@manager{hardware}
Goes through a list of servers, add the specified vlan to each one
&amp;quot;&amp;quot;&amp;quot;

import SoftLayer

class testVlanTag():
    def __init__(self):
        &amp;quot;&amp;quot;&amp;quot;SoftLayer Client&amp;quot;&amp;quot;&amp;quot;
        self.client = SoftLayer.Client()
        self.mgr = SoftLayer.HardwareManager(self.client)    

    def addVlanTrunks(self, id, vlans):
        &amp;quot;&amp;quot;&amp;quot;
            Adds a vlan to a network component
            @param id ID of SoftLayer_Network_Component you want to add vlan to
            @param vlans dictionary of vlan nubmers you want to add
            @sldn{SoftLayer_Network_Component,addNetworkVlanTrunks}
            @sldn{SoftLayer_Network_Component,getNetworkVlanTrunks}
        &amp;quot;&amp;quot;&amp;quot;
        for vlanNumber in vlans:
            print &amp;quot;Adding vlan %s to %s&amp;quot; % (vlanNumber,id)
            result = self.client[&#39;Network_Component&#39;].addNetworkVlanTrunks([{&#39;vlanNumber&#39;:vlanNumber}],id=id)
            vlan = self.client[&#39;Network_Component&#39;].getNetworkVlanTrunks(id=id)


    def main(self):
        &amp;quot;&amp;quot;&amp;quot;
            Runs through a list of server ids and tags them with the proper vlan
            Does both public and private interfaces
        &amp;quot;&amp;quot;&amp;quot;
        &amp;quot;&amp;quot;&amp;quot;comma seperated list of ids&amp;quot;&amp;quot;&amp;quot;
        serverIds = [14274503]
        &amp;quot;&amp;quot;&amp;quot;comma seperated list of public vlan nubmers to tag on each server&amp;quot;&amp;quot;&amp;quot;
        publicVlanNumbers = [1125,1110]
        &amp;quot;&amp;quot;&amp;quot;comma seperated list of private vlan nubmers to tag on each server&amp;quot;&amp;quot;&amp;quot;
        privateVlanNumbers = [1110]

        for sid in serverIds:
            hardware = self.mgr.get_hardware(sid)
            privateIP = hardware[&#39;primaryBackendIpAddress&#39;]
            print &amp;quot;Private IP is: %s&amp;quot; % (privateIP) 
            publicIP = hardware[&#39;primaryIpAddress&#39;]
            print &amp;quot;Public IP is: %s&amp;quot; % (publicIP)

            for component in hardware[&#39;networkComponents&#39;]:
                try:
                    if (component[&#39;primaryIpAddress&#39;] == publicIP):
                        continue
                        # self.addVlanTrunks(component[&#39;id&#39;],publicVlanNumbers)
                    elif (component[&#39;primaryIpAddress&#39;] == privateIP):
                        self.addVlanTrunks(component[&#39;id&#39;],privateVlanNumbers)
                    # result = self.client[&#39;Network_Component&#39;].clearNetworkVlanTrunks(id=component[&#39;id&#39;])
                    mask = &#39;networkVlan, networkVlanTrunks, uplinkComponent[networkVlanTrunks]&#39;
                    nic = self.client[&#39;Network_Component&#39;].getObject(id=component[&#39;id&#39;], mask=mask)
                except KeyError:
                    continue

            print &amp;quot;Done with %s &amp;quot; % (hardware[&#39;hostname&#39;])
            print &amp;quot;=====================================&amp;quot;  

if __name__ == &amp;quot;__main__&amp;quot;:
    main = testVlanTag()
    main.main()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Get Virtual Console Virtual Guest</title>
      <link>https://softlayer.github.io/python/getkvmdetails/</link>
      <pubDate>Thu, 04 May 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/getkvmdetails/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
@author Ryan Tiffany
&amp;quot;&amp;quot;&amp;quot;

import SoftLayer
from pprint import pprint as pp

client = SoftLayer.Client()

mask = &amp;quot;mask[consoleIpAddressRecord[ipAddress[ipAddress],port],operatingSystem[passwords]]&amp;quot;

getDetails = client[&#39;SoftLayer_Virtual_Guest&#39;].getObject(mask=mask,id=31678643)
pp(getDetails)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Reloading a server with a custom partition scheme</title>
      <link>https://softlayer.github.io/python/reloadcustompartition/</link>
      <pubDate>Wed, 29 Mar 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/reloadcustompartition/</guid>
      <description>&lt;p&gt;The following code allows you to reload a Bare Metal server with a custom partitioning scheme. You simply need to change the serverId and the partitions to suit your needs. Note that one partition must be marked as the &amp;lsquo;grow&amp;rsquo; partition.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import SoftLayer
from pprint import pprint as pp

class example():

    def __init__(self):
        self.client = SoftLayer.Client()

    def main(self):
        serverId = 1154505
        config = {
        &amp;quot;upgradeHardDriveFirmware&amp;quot;: &amp;quot;0&amp;quot;,
        &amp;quot;upgradeBios&amp;quot;: &amp;quot;0&amp;quot;,
        &amp;quot;hardDrives&amp;quot;: [
            {
                &amp;quot;complexType&amp;quot;: &amp;quot;SoftLayer_Hardware_Component_HardDrive&amp;quot;,
                &amp;quot;partitions&amp;quot;: [
                    { &amp;quot;name&amp;quot;: &amp;quot;/boot&amp;quot;, &amp;quot;minimumSize&amp;quot;: &amp;quot;.25&amp;quot;},
                    { &amp;quot;name&amp;quot;: &amp;quot;/swap0&amp;quot;, &amp;quot;minimumSize&amp;quot;: &amp;quot;20&amp;quot;},
                    { &amp;quot;name&amp;quot;: &amp;quot;/&amp;quot;, &amp;quot;minimumSize&amp;quot;: &amp;quot;200&amp;quot;},
                    { &amp;quot;name&amp;quot;: &amp;quot;/tmp&amp;quot;, &amp;quot;minimumSize&amp;quot;: &amp;quot;200&amp;quot;},
                    { &amp;quot;name&amp;quot;: &amp;quot;/var&amp;quot;, &amp;quot;minimumSize&amp;quot;: &amp;quot;200&amp;quot;},
                    { &amp;quot;name&amp;quot;: &amp;quot;/remove&amp;quot;, &amp;quot;minimumSize&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;grow&amp;quot;: &amp;quot;1&amp;quot;}
                ]
            }
        ]
     }

        output = self.client[&#39;Hardware_Server&#39;].reloadOperatingSystem(&#39;FORCE&#39;, config, id=serverId)

        pp(config)
        print &amp;quot;RESULT\n&amp;quot;
        pp(output)

if __name__ == &amp;quot;__main__&amp;quot;:
    main = example()
    main.main()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Network Topology</title>
      <link>https://softlayer.github.io/python/networktopology/</link>
      <pubDate>Fri, 17 Mar 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/networktopology/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot;
@author Christopher Gallo
&amp;quot;&amp;quot;&amp;quot;
import SoftLayer
from pprint import pprint as pp

class example():

    def __init__(self):

        self.client = SoftLayer.Client()


    def main(self):

        mask = &amp;quot;&amp;quot;&amp;quot;
            mask[attachedNetworkGateway[publicVlan,privateVlan],hardware[fullyQualifiedDomainName],
            network,networkSpace,primaryRouter[hostname],primarySubnet,subnets[networkIdentifier],virtualGuests[fullyQualifiedDomainName]
            ]
        &amp;quot;&amp;quot;&amp;quot;
        orderedVlans = {}
        result = self.client[&#39;SoftLayer_Account&#39;].getNetworkVlans(mask=mask)

        &amp;quot;&amp;quot;&amp;quot;
        This bit builds a nicely structured object of the network topology
        &amp;quot;&amp;quot;&amp;quot;
        for vlan in result:
            vlanNumber = vlan[&#39;vlanNumber&#39;]
            router,dc  = vlan[&#39;primaryRouter&#39;][&#39;hostname&#39;].split(&amp;quot;.&amp;quot;)
            if dc not in orderedVlans:
                orderedVlans[dc] = {}
            if router not in orderedVlans[dc]:
                orderedVlans[dc][router] = {}


            toAppend = {
                &#39;hardware&#39;: vlan[&#39;hardware&#39;],
                &#39;virtualGuests&#39;: vlan[&#39;virtualGuests&#39;],
                &#39;subnets&#39;: vlan[&#39;subnets&#39;]

            }

            if &#39;attachedNetworkGateway&#39; in vlan:
                if vlan[&#39;networkSpace&#39;] == &#39;PUBLIC&#39;:
                    gatewayVlan = vlan[&#39;attachedNetworkGateway&#39;][&#39;publicVlan&#39;][&#39;vlanNumber&#39;]
                elif vlan[&#39;networkSpace&#39;] == &#39;PRIVATE&#39;:
                    gatewayVlan = vlan[&#39;attachedNetworkGateway&#39;][&#39;privateVlan&#39;][&#39;vlanNumber&#39;]
                if gatewayVlan not in orderedVlans[dc][router]:
                    orderedVlans[dc][router][gatewayVlan] = {}
                orderedVlans[dc][router][gatewayVlan][vlanNumber] = toAppend
                orderedVlans[dc][router][gatewayVlan][&#39;gateway&#39;] = True
            else:
                orderedVlans[dc][router][vlanNumber] = toAppend

        &amp;quot;&amp;quot;&amp;quot;
        This bit prints out everything nicely-ish.
        &amp;quot;&amp;quot;&amp;quot;
        for dc in orderedVlans:
            print(&amp;quot;DC: %s&amp;quot; % dc)
            for router in orderedVlans[dc]:
                print(&amp;quot;\tRouter: %s&amp;quot; % router)
                for vlan in orderedVlans[dc][router]:
                    if &#39;gateway&#39; in orderedVlans[dc][router][vlan]:
                        print(&amp;quot;\t\tGATEWAY VLAN: %s&amp;quot; % vlan )
                        for vlanInner in orderedVlans[dc][router][vlan]:

                            if isinstance(vlanInner, int):
                                print(&amp;quot;\t\t\tVLAN: %s&amp;quot; % vlanInner )
                                if len(orderedVlans[dc][router][vlan][vlanInner][&#39;hardware&#39;]):
                                    print(&amp;quot;\t\t\t  ==SERVERS==&amp;quot;)
                                    for hardware in orderedVlans[dc][router][vlan][vlanInner][&#39;hardware&#39;]:
                                        print(&amp;quot;\t\t\t\t%s&amp;quot; % hardware[&#39;fullyQualifiedDomainName&#39;])
                                if len(orderedVlans[dc][router][vlan][vlanInner][&#39;virtualGuests&#39;]):
                                    print(&amp;quot;\t\t\t  ==VIRTUAL SERVERS==&amp;quot;)
                                    for virtualGuest in orderedVlans[dc][router][vlan][vlanInner][&#39;virtualGuests&#39;]:
                                        print(&amp;quot;\t\t\t\t%s&amp;quot; % virtualGuest[&#39;fullyQualifiedDomainName&#39;])
                                if len(orderedVlans[dc][router][vlan][vlanInner][&#39;subnets&#39;]):
                                    print(&amp;quot;\t\t\t  ==SUBNETS==&amp;quot;)
                                    for subnet in orderedVlans[dc][router][vlan][vlanInner][&#39;subnets&#39;]:
                                        print(&amp;quot;\t\t\t\t%s&amp;quot; % subnet[&#39;networkIdentifier&#39;])
                    else:
                        print(&amp;quot;\t\tVLAN: %s&amp;quot; % vlan )

                    if len(orderedVlans[dc][router][vlan][&#39;hardware&#39;]):
                        print(&amp;quot;\t\t  ==SERVERS==&amp;quot;)
                        for hardware in orderedVlans[dc][router][vlan][&#39;hardware&#39;]:
                            print(&amp;quot;\t\t\t%s&amp;quot; % hardware[&#39;fullyQualifiedDomainName&#39;])
                    if len(orderedVlans[dc][router][vlan][&#39;virtualGuests&#39;]):
                        print(&amp;quot;\t\t  ==VIRTUAL SERVERS==&amp;quot;)
                        for vm in orderedVlans[dc][router][vlan][&#39;virtualGuests&#39;]:
                            print(&amp;quot;\t\t\t%s&amp;quot; % vm[&#39;fullyQualifiedDomainName&#39;])
                    if len(orderedVlans[dc][router][vlan][&#39;subnets&#39;]):
                        print(&amp;quot;\t\t  ==SUBNETS==&amp;quot;)
                        for subnet in orderedVlans[dc][router][vlan][&#39;subnets&#39;]:
                            print(&amp;quot;\t\t\t%s&amp;quot; % subnet[&#39;networkIdentifier&#39;])


if __name__ == &amp;quot;__main__&amp;quot;:
    main = example()
    main.main()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DC: sjc03
    Router: bcr02a
        VLAN: 904
          ==VIRTUAL SERVERS==
            jrh-jump.poc.engineering
          ==SUBNETS==
            10.168.140.0
    Router: bcr01a
        GATEWAY VLAN: 1436
            VLAN: 1440
              ==SERVERS==
                jd-test-5600-srv.secore.com
                jd-cos-testing-sjc03.secore.com
              ==SUBNETS==
                10.161.111.64
          ==SERVERS==
            jd-5600-test.secore.com
          ==SUBNETS==
            10.161.110.0
    Router: fcr02a
        VLAN: 857
          ==VIRTUAL SERVERS==
            jrh-jump.poc.engineering
          ==SUBNETS==
            169.44.183.224
    Router: fcr01a
        VLAN: 1296
          ==SERVERS==
            jd-test-5600-srv.secore.com
            jd-cos-testing-sjc03.secore.com
          ==SUBNETS==
            169.45.115.16
            2607:f0d0:2601:00cc:0000:0000:0000:0000
        VLAN: 1273
          ==SERVERS==
            jd-5600-test.secore.com
          ==SUBNETS==
            169.44.136.64
            2607:f0d0:2601:0065:0000:0000:0000:0000
            2607:f0d0:2601:00ac:0000:0000:0000:0000
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Endurance Storage Replication</title>
      <link>https://softlayer.github.io/python/endurancereplication/</link>
      <pubDate>Tue, 21 Feb 2017 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/endurancereplication/</guid>
      <description>&lt;p&gt;Some good starting reading.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://knowledgelayer.softlayer.com/procedure/endurance-replication&#34;&gt;https://knowledgelayer.softlayer.com/procedure/endurance-replication&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://knowledgelayer.softlayer.com/procedure/endurance-snapshots&#34;&gt;https://knowledgelayer.softlayer.com/procedure/endurance-snapshots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Network_Storage/enableSnapshots&#34;&gt;http://sldn.softlayer.com/reference/services/SoftLayer_Network_Storage/enableSnapshots&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For more information on the magic of storage ordering see the following&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/softlayer/softlayer-python/blob/master/SoftLayer/managers/file.py&#34;&gt;https://github.com/softlayer/softlayer-python/blob/master/SoftLayer/managers/file.py&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/softlayer/softlayer-python/blob/master/SoftLayer/managers/storage_utils.py&#34;&gt;https://github.com/softlayer/softlayer-python/blob/master/SoftLayer/managers/storage_utils.py&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This example should touch on all the basics of dealing with endurance storage replication volumes. This example uses the SoftLayer-python File manager a little bit for ordering&lt;/p&gt;

&lt;p&gt;TO authorize hosts that are NOT virtual guests, see the allowAccessFrom* methods in&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Network_Storage/&#34;&gt;http://sldn.softlayer.com/reference/services/SoftLayer_Network_Storage/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Graceful vs Immediate failover&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Network_Storage/immediateFailoverToReplicant&#34;&gt;http://sldn.softlayer.com/reference/services/SoftLayer_Network_Storage/immediateFailoverToReplicant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Network_Storage/failoverToReplicant&#34;&gt;http://sldn.softlayer.com/reference/services/SoftLayer_Network_Storage/failoverToReplicant&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Failback is always immediate.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;
@package examples 
@author Christopher Gallo
&amp;quot;&amp;quot;&amp;quot;

import SoftLayer
import logging
from pprint import pprint as pp

class example():

    def __init__(self):
        &amp;quot;&amp;quot;&amp;quot;
        If you need debugging, uncomment these. be prepared for a lot of XML
        &amp;quot;&amp;quot;&amp;quot;
        # logger = logging.getLogger()
        # logger.addHandler(logging.StreamHandler())
        # logger.setLevel(3)
        self.client = SoftLayer.Client()
        self.storage = self.client[&#39;SoftLayer_Network_Storage&#39;]
        self.mgr = SoftLayer.FileStorageManager(self.client)
        # Broken up like this to look &#39;good&#39; on softlayer.github.io
        self.objectMask = &amp;quot;mask[&amp;quot;
            &amp;quot;id, username, capacityGb, bytesUsed, serviceResource[datacenter[name]], &amp;quot;
            &amp;quot;serviceResourceBackendIpAddress, activeTransactionCount, &amp;quot;
            &amp;quot;fileNetworkMountAddress, snapshots[id,createDate], hourlySchedule, &amp;quot; 
            &amp;quot;allowedReplicationVirtualGuests[hostname], allowedVirtualGuests[hostname], &amp;quot;
            &amp;quot;replicationStatus, replicationPartners]&amp;quot;

    def orderStorage(self):
        &amp;quot;&amp;quot;&amp;quot;
        This will order endurance storage in HOU02 with 20G in size, and the 0.25IOPS/GB tier
        0.25, 2, 4 and 10 iops/g are tiers available. 
        &amp;quot;&amp;quot;&amp;quot;
        result = self.mgr.order_file_volume(
            storage_type=&amp;quot;storage_service_enterprise&amp;quot;,
            location = &amp;quot;hou02&amp;quot;,
            size = 20,
            tier_level = 0.25
            )
        pp(result)

    def orderSnapshot(self, volume_id):
        result = self.mgr.order_snapshot_space(
            volume_id=volume_id,
            capacity=20,
            tier = 0.25,
            upgrade=False)
        pp(result)

    def orderReplicant(self, volume_id, schedule):
        &amp;quot;&amp;quot;&amp;quot;
        Same as other ordering methods, schedule is 
        &amp;quot;HOURLY&amp;quot;, &amp;quot;DAILY&amp;quot; or &amp;quot;WEEKLY&amp;quot;
        &amp;quot;&amp;quot;&amp;quot;
        result = self.mgr.order_replicant_volume(
            volume_id=volume_id,
            snapshot_schedule=schedule,
            location = &amp;quot;dal06&amp;quot;,
            tier = 0.25
        )
        pp(result)



    def listStoragePrices(self):
        &amp;quot;&amp;quot;&amp;quot;
        222 - Performance - PERFORMANCE_STORAGE_SERVICE
        240 - Endurance - CODENAME_PRIME_STORAGE
        If you feel like building the pricing object yourself, start here.
        &amp;quot;&amp;quot;&amp;quot;
        mask = &amp;quot;mask[items[prices[pricingLocationGroup,categories],attributes]]&amp;quot;
        # locations = self.client[&#39;Product_Package&#39;].getLocations(id=package_id)
        result = self.client[&#39;Product_Package&#39;].getObject(mask=mask,id=240)
        for item in result[&#39;items&#39;]:
            print(&amp;quot;%s - %s - %s&amp;quot; % 
                (str(item[&#39;id&#39;]), item[&#39;description&#39;], item[&#39;keyName&#39;]) 
            # pp(item)
            for prices in item[&#39;prices&#39;]:
                if prices[&#39;locationGroupId&#39;] is  &#39;&#39;:
                    print &amp;quot;\t&amp;quot; + str(prices[&#39;id&#39;])
                # pp(prices)

    def listStorage(self):
    &amp;quot;&amp;quot;&amp;quot;
    Super complicated objectFilter. Mostly here as an example of how to do an IN filter.
    Returns all storage that is in DAL06, HOU02, is NOT NAS, and is Endurance_File_Storage
    &amp;quot;&amp;quot;&amp;quot;
        objectFilter = {
            &#39;nasNetworkStorage&#39;: {
                &#39;serviceResource&#39;: {
                    &#39;type&#39;: {
                        &#39;type&#39;: {&#39;operation&#39;: &#39;!~ NAS&#39;}
                    },
                    &#39;datacenter&#39;: {
                        &#39;name&#39;: {
                            &#39;operation&#39;: &#39;in&#39;,
                            &#39;options&#39;: [{
                                &#39;name&#39;: &#39;data&#39;,
                                &#39;value&#39;: [&#39;dal06&#39;,&#39;hou02&#39;]
                            }]
                        }
                    }
                },
                &#39;storageType&#39;: {
                    &#39;keyName&#39;: {&#39;operation&#39;: &#39;ENDURANCE_FILE_STORAGE&#39;}
                }
            }
        }
        result = self.client[&#39;Account&#39;].getNasNetworkStorage(
            mask=self.objectMask,filter=objectFilter)
        pp(result)

    def authHost(self, volume_id, host_id):
    &amp;quot;&amp;quot;&amp;quot;
    each host that needs to mount the volume needs to be authorized.
    host and volume need to be in the same DC
    &amp;quot;&amp;quot;&amp;quot;
        guest = {
            &#39;id&#39;: host_id
        }
        self.storage.allowAccessFromVirtualGuest(guest, id=volume_id)

    def authReplicant(self, volume_id, host_id):
    &amp;quot;&amp;quot;&amp;quot;
    each host that needs to mount the REPLICANT needs to be authorized.
    host and volume need to be in the same DC
    &amp;quot;&amp;quot;&amp;quot;
        guest = {
            &#39;id&#39;: host_id
        }
        self.storage.allowAccessToReplicantFromVirtualGuest(guest, id=volume_id)

    def createSnapSchedule(self, volume_id):
        # HOURLY, 24 copies, first minute of the hour. 
        self.storage.enableSnapshots(&#39;HOURLY&#39;, 24, 1, 0, 0, id=volume_id)

    def manualSnap(self, volume_id):
        self.storage.createSnapshot(&#39;Manual SNAP&#39;, id=volume_id)

    def getReplicantId(self, volume_id):
        &amp;quot;&amp;quot;&amp;quot;
        there might be more than 1 replicant id in this list if there are more 
        than 1 replicant targets. Or none of course.
        &amp;quot;&amp;quot;&amp;quot;
        result = self.storage.getReplicationPartners(id=volume_id)
        return result[0][&#39;id&#39;]
        

    def houIsDown(self, volume_id, now=False):

        replicate_to = main.getReplicantId(volume_id)
        if now:
            self.storage.immediateFailoverToReplicant(replicate_to, id=volume_id)
        else
            self.storage.failoverToReplicant(replicate_to, id=volume_id)

    def houIsBack(self, volume_id):
        self.storage.failbackFromReplicant(id=volume_id,now=False)

    def volumeStatus(self, volume_id):
        result = self.storage.getObject(mask=self.objectMask, id=volume_id)
        pp(result)


if __name__ == &amp;quot;__main__&amp;quot;:
&amp;quot;&amp;quot;&amp;quot;
Covers each of the steps required to create a storage volume, and then fail it over.
The ordering methods will need to be slightly modified for block storage. 
everything else should be good as is.

&amp;quot;&amp;quot;&amp;quot;

    host_a = 25206857
    host_b = 28630647
    main = example()
    main.listStorage()
    ### First we need to order a storage volume, and get its ID.
    # main.orderStorage()
    volume_id = 20017773

    ### Then we need to order snapshot space
    # main.orderSnapshot(volume_id)

    ### Then create a snapshot schedule.
    # main.createSnapSchedule(volume_id)

    ### Then Allow our host to access the volume
    # main.authHost(volume_id, [host_a])

    ### Create a manual snapshot for fun 
    # main.manualSnap(volume_id)

    ### Order replication space.
    # main.orderReplicant(volume_id, &#39;HOURLY&#39;)

    ### Allow our vm to access replicant volume
    # main.authReplicant(volume_id,host_b)

    ### Failover to replicant
    # main.houIsDown(volume_id)

    ### Failback to main
    # main.houIsBack(volume_id)

    ### Get some status
    # main.volumeStatus(volume_id)

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>