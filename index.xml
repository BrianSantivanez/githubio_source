<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title> on SoftLayer API Examples </title>
    <link>https://softlayer.github.io/</link>
    <language>en-US</language>
    <author>Enthusiastic Hugo User</author>
    <rights>Copyright (c) 2014, Enthusiastic Hugo User; all rights reserved.</rights>
    <updated>Mon, 18 Apr 2016 00:00:00 UTC</updated>
    
    <item>
      <title>Release notes: April 18, 2016</title>
      <link>https://softlayer.github.io/release_notes/20160418/</link>
      <pubDate>Mon, 18 Apr 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/release_notes/20160418/</guid>
      <description>

&lt;h4 id=&#34;portal:b0ae1fc0f77d3ea1dc28e8e43fcaa10d&#34;&gt;Portal&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Fixed an issue where R1Soft Server options were not showing up while initiating an OS Reload.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;api:b0ae1fc0f77d3ea1dc28e8e43fcaa10d&#34;&gt;API&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Added &lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Account/getVmWareActiveAccountLicenseKeys&#34;&gt;getVmWareActiveAccountLicenseKeys&lt;/a&gt; to SoftLayer_Account service.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;backend:b0ae1fc0f77d3ea1dc28e8e43fcaa10d&#34;&gt;Backend&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Resolved a bug in which hosts authorized to multiple iSCSI Volumes became deauthorized from all iSCSI Volumes when one Volume was explicitly deauthorized.&lt;/li&gt;
&lt;li&gt;Resolved an issue that was preventing Local Load Balancers and Netscalers from completing the provisioning process due to an errant RAID card check.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Find Location specific pricing for a package</title>
      <link>https://softlayer.github.io/python/location_based_pricing/</link>
      <pubDate>Tue, 12 Apr 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/location_based_pricing/</guid>
      <description>&lt;p&gt;With the introduction to Location-based Pricing, we updated our pricing model to represent the costs in each data center more clearly. Instead of adding premiums to a base server price, we have priced servers and services in each data center with their own location-based &lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Product_Item_Price&#34;&gt;SoftLayer_Product_Item_Price&lt;/a&gt; objects via the API. In the following example we will query for the Dallas 6 data center, and then filter our item (Local Load Balancer) and prices to include only the location-based pricing for the specific data center we&amp;rsquo;re in â€”or we can filter for the standard price if a location-based price doesn&amp;rsquo;t exist.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
import SoftLayer
import json

package_id = 194
datacenter = &#39;dal06&#39;

client = SoftLayer.Client()

location_object_filter = {
    &#39;name&#39;: {&#39;operation&#39;: datacenter}
}

location_object_mask = &amp;quot;priceGroups&amp;quot;

location = client[&amp;quot;SoftLayer_Location_Datacenter&amp;quot;].getDatacenters(filter=location_object_filter, mask=location_object_mask)

if len(location) == 0:
    # error handling
    exit()

# lookup location group ids
location_group_ids = []
for location_group in location[0][&amp;quot;priceGroups&amp;quot;]:
    location_group_ids.append(location_group[&amp;quot;id&amp;quot;])

object_filter_standard = {
    &#39;items&#39;: {
        &amp;quot;prices&amp;quot;: {
            &amp;quot;locationGroupId&amp;quot;: {
                &amp;quot;operation&amp;quot;: &amp;quot;is null&amp;quot;
            }
        }
    }
}

standard_items = client[&amp;quot;SoftLayer_Product_Package&amp;quot;].getItems(id=package_id, filter=object_filter_standard)

object_filter_location = {
    &#39;items&#39;: {
        &amp;quot;prices&amp;quot;: {
            &amp;quot;locationGroupId&amp;quot;: {
                &amp;quot;operation&amp;quot;: &amp;quot;in&amp;quot;,
                &amp;quot;options&amp;quot;: [
                    {
                        &amp;quot;name&amp;quot;: &amp;quot;data&amp;quot;,
                        &amp;quot;value&amp;quot;: location_group_ids
                    }
                ]
            }
        }
    }
}

location_items = client[&amp;quot;SoftLayer_Product_Package&amp;quot;].getItems(id=package_id, filter=object_filter_location)

# let&#39;s key by item id
items = {}

for standard_item in standard_items:
    for location_item in location_items:
        if location_item[&amp;quot;id&amp;quot;] == standard_item[&amp;quot;id&amp;quot;]:
            items[location_item[&amp;quot;id&amp;quot;]] = location_item
            break

    if standard_item[&amp;quot;id&amp;quot;] not in items:
        items[standard_item[&amp;quot;id&amp;quot;]] = standard_item


print(json.dumps(items, sort_keys=True, indent=2, separators=(&#39;,&#39;, &#39;: &#39;)))


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find standard location pricing for a package</title>
      <link>https://softlayer.github.io/python/standard_pricing/</link>
      <pubDate>Tue, 12 Apr 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/standard_pricing/</guid>
      <description>&lt;p&gt;With the introduction to Location-based Pricing, we updated our pricing model to represent the costs in each data center more clearly. Instead of adding premiums to a base server price, we have priced servers and services in each data center with their own location-based &lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Product_Item_Price&#34;&gt;SoftLayer_Product_Item_Price&lt;/a&gt; objects via the API. The following example shows how to get the Standard priceItemId for a package regardless of the location.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
import SoftLayer
import json

object_filter = {
    &#39;items&#39;: {
        &#39;prices&#39;: {
            &#39;locationGroupId&#39;: {
                &#39;operation&#39;: &#39;is null&#39;
            }
        }
    }
}

client = SoftLayer.Client()
items = client[&amp;quot;SoftLayer_Product_Package&amp;quot;].getItems(id=194, filter=object_filter)

print(json.dumps(items, sort_keys=True, indent=2, separators=(&#39;,&#39;, &#39;: &#39;)))

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Release notes: April 11, 2016</title>
      <link>https://softlayer.github.io/release_notes/20160411/</link>
      <pubDate>Mon, 11 Apr 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/release_notes/20160411/</guid>
      <description>

&lt;h4 id=&#34;portal:85777ae8ba6274540c4293927990daf8&#34;&gt;Portal&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;To align closer to the IBM Cloud user experience the portal interface color scheme and feel have been updated. All functionality has remained in place.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;api:85777ae8ba6274540c4293927990daf8&#34;&gt;API&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;None&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;backend:85777ae8ba6274540c4293927990daf8&#34;&gt;Backend&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Resolved an issue what was preventing upgrades of Network Gateway Devices in to a High Availability Pair.&lt;/li&gt;
&lt;li&gt;Added functionality to alert users via email when the email account or password is changed for their portal user.&lt;/li&gt;
&lt;li&gt;To speed up provisioning times and remove the need for manual intervention a function was implemented to pair a Raid Card when an order contains an SSD or SAS Drive during the provision process.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Release notes: April 4, 2016</title>
      <link>https://softlayer.github.io/release_notes/20160404/</link>
      <pubDate>Mon, 04 Apr 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/release_notes/20160404/</guid>
      <description>

&lt;h4 id=&#34;portal:460e5c802b9ca2a2382b95392cadb303&#34;&gt;Portal&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Fixed an issue in which a ticket was unable to be updated if there was special text in the ticket update.&lt;/li&gt;
&lt;li&gt;Resolved an issue where the order forms were not loading properly for non-English languages.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;api:460e5c802b9ca2a2382b95392cadb303&#34;&gt;API&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Resolved an issue where the description for &lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Metric_Tracking_Object/getObject&#34;&gt;SoftLayer_Metric_Tracking_Object::getObject&lt;/a&gt; was not appearing on SLDN or API metadata.&lt;/li&gt;
&lt;li&gt;Resolved an issue in which creating a Bare Metal server via &lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Hardware/createObject&#34;&gt;SoftLayer_Hardware::createObject&lt;/a&gt; was setting the RAM value to 0GB.&lt;/li&gt;
&lt;li&gt;Resolved an issue with &lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Search/search&#34;&gt;SoftLayer_Search::search&lt;/a&gt; not returning the same results as &lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Search/advancedSearch&#34;&gt;SoftLayer_Search::advancedSearch&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Added &lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Network_Storage/createSnapshot&#34;&gt;createSnapshot&lt;/a&gt; method to Endurance storage volumes to enable manual snapshots to be created via API.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;backend:460e5c802b9ca2a2382b95392cadb303&#34;&gt;Backend&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Updated code so that ticket updates no longer send duplicate emails if two subscribers/users exist with the same email address.&lt;/li&gt;
&lt;li&gt;Updated the logic on &lt;a href=&#34;http://www.softlayer.com/bare-metal-search&#34;&gt;http://www.softlayer.com/bare-metal-search&lt;/a&gt; so that when you choose a Bare Metal server the subsequent page will only show Datacenters in which that configuration is avilable.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Release notes: March 28, 2016</title>
      <link>https://softlayer.github.io/release_notes/20160328/</link>
      <pubDate>Mon, 28 Mar 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/release_notes/20160328/</guid>
      <description>

&lt;h4 id=&#34;portal:1081b0aac7560b053b9bd4652a2c481d&#34;&gt;Portal&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Fixed an issue that was preventing customers from properly saving modifications on existing quotes from the Customer portal.&lt;/li&gt;
&lt;li&gt;Fixed a bug that was causing slow response on the ordering checkout page.&lt;/li&gt;
&lt;li&gt;Resolved an issue that was affecting upgrading a Vyatta to an High Availability pair.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;api:1081b0aac7560b053b9bd4652a2c481d&#34;&gt;API&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;None&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;backend:1081b0aac7560b053b9bd4652a2c481d&#34;&gt;Backend&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Enable Order support for Account Defined Networking Virtual Guests.&lt;/li&gt;
&lt;li&gt;Resolved an issue that caused snapshot space threshold alerts to repeatedly update tickets with the same information.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Upgrade Hardware and Virtual Servers</title>
      <link>https://softlayer.github.io/python/upgrade_examples/</link>
      <pubDate>Tue, 22 Mar 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/upgrade_examples/</guid>
      <description>&lt;pre&gt;&lt;code&gt;import SoftLayer
from pprint import pprint as pp

class example():

    def __init__(self):
        self.client = SoftLayer.Client()

    &amp;quot;&amp;quot;&amp;quot;
    Prints out what can be upgraded on a server by category.
    &amp;quot;&amp;quot;&amp;quot;
    def getUpgradeItemPrices(self, hardware_id, service=&#39;SoftLayer_Hardware_Server&#39;):
        result = self.client[service].getUpgradeItemPrices(id=hardware_id)
        last_id = 0
        for item in result:
            now_id = item[&#39;categories&#39;][0][&#39;id&#39;]
            if now_id != last_id:
                print(&amp;quot;%s (%s)&amp;quot; % (item[&#39;categories&#39;][0][&#39;name&#39;], item[&#39;categories&#39;][0][&#39;id&#39;]))
            last_id = now_id
            print(&amp;quot;\t %s (%s)&amp;quot; % (item[&#39;item&#39;][&#39;description&#39;], item[&#39;id&#39;]))


    &amp;quot;&amp;quot;&amp;quot;
    Get the available maintenance windows that exist for a server.
    &amp;quot;now&amp;quot; is still always an option
    &amp;quot;&amp;quot;&amp;quot;
    def getUpgradeTimes(self, hardware_id, beginDate, endDate):
        # getLocation doesn&#39;t return an id that is useful for getMaintenanceWindows
        # Needs to be the datacenter ID, not the location id...
        _mask = &amp;quot;mask[datacenter]&amp;quot;
        server = self.client[&#39;SoftLayer_Hardware_Server&#39;].getObject(id=hardware_id,mask=_mask)
        pp(server)
        location_id = server[&#39;datacenter&#39;][&#39;id&#39;]
        provision_service = self.client[&#39;SoftLayer_Provisioning_Maintenance_Window&#39;]
        windows = provision_service.getMaintenanceWindows(beginDate, endDate, location_id, 1)
        pp(windows)


    &amp;quot;&amp;quot;&amp;quot;
    Upgrades the network speed 1Gbps (price id = 274)
    MAINTENANCE_WINDOW requires both the time, AND the id of the maintenance window. Virtual Server upgrades do not require the ID, just bare metal.
    &amp;quot;&amp;quot;&amp;quot;
    def upgradeServer(self, hardware_id, place_order=False):
        product_client = self.client[&#39;SoftLayer_Product_Order&#39;]
        upgrade = {
            &#39;complexType&#39; : &#39;SoftLayer_Container_Product_Order_Hardware_Server_Upgrade&#39;,
            &#39;hardware&#39; : [{&#39;id&#39; : hardware_id}],
            &#39;properties&#39; : [
                {
                    &#39;name&#39; : &#39;MAINTENANCE_WINDOW&#39;, 
                    &#39;value&#39; : &#39;2016-03-30T00:00:00-06:00&#39;
                },
                {
                    &#39;name&#39; : &#39;MAINTENANCE_WINDOW_ID&#39;, 
                    &#39;value&#39; : 7
                }
            ],
            &#39;prices&#39;: [{&#39;id&#39; : 274}]
        }
        pp(upgrade)
        print(&amp;quot;Verifying Order....&amp;quot;)
        result = product_client.verifyOrder(upgrade)
        pp(result)
        if place_order:
            print(&amp;quot;PLACING ORDER....&amp;quot;)
            place_result = product_client.placeOrder(upgrade)
            pp(place_result)


    &amp;quot;&amp;quot;&amp;quot;
    Adds a 10G disk (price id = 2255) to the second (id=82) and third (id=92)
    disk slots on the VSI. The price for both is the same, you just need to specify
    the propery category for each disk.
    &amp;quot;&amp;quot;&amp;quot;
    def upgradeVSI(self, vsi_id, place_order=False):
        product_client = self.client[&#39;SoftLayer_Product_Order&#39;]
        upgrade = {
            &#39;complexType&#39; : &#39;SoftLayer_Container_Product_Order_Virtual_Guest_Upgrade&#39;,
            &#39;virtualGuests&#39; : [{&#39;id&#39; : vsi_id}],
            &#39;properties&#39; : [
                {
                    &#39;name&#39; : &#39;MAINTENANCE_WINDOW&#39;, 
                    &#39;value&#39; : &#39;2016-03-23 16:00:00&#39;
                }
            ],
            &#39;prices&#39;: [
                {
                    &#39;categories&#39; : [{&#39;id&#39; : 82}],
                    &#39;id&#39; : 2255
                },
                {
                    &#39;categories&#39; : [{&#39;id&#39; : 92}],
                    &#39;id&#39; : 2255
                }
            ]
        }
        pp(upgrade)
        print(&amp;quot;Verifying Order....&amp;quot;)
        result = product_client.verifyOrder(upgrade)
        pp(result)
        if place_order:
            print(&amp;quot;PLACING ORDER....&amp;quot;)
            place_result = product_client.placeOrder(upgrade)
            pp(place_result)


    &amp;quot;&amp;quot;&amp;quot;
    Gets some information about any current upgrade requests for a server
    &amp;quot;&amp;quot;&amp;quot;
    def getUpgradeInfo(self, hardware_id, service=&#39;SoftLayer_Hardware_Server&#39;):
        result = self.client[service].getUpgradeRequest(id=hardware_id)
        pp(result)

if __name__ == &amp;quot;__main__&amp;quot;:
    main = example()
    server_id = 662657
    # main.getUpgradeItemPrices(server_id)
    # main.getUpgradeTimes(server_id, &#39;2016-03-30 00:00:00&#39;, &#39;2016-03-31 20:00:00&#39;)
    # main.upgradeServer(server_id, True)
    vsi_id = 13106845
    # main.getUpgradeItemPrices(vsi_id,&#39;SoftLayer_Virtual_Guest&#39;)
    # main.upgradeVSI(vsi_id, True)
    main.getUpgradeInfo(vsi_id,&#39;SoftLayer_Virtual_Guest&#39; )
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Release notes: March 21, 2016</title>
      <link>https://softlayer.github.io/release_notes/20160321/</link>
      <pubDate>Mon, 21 Mar 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/release_notes/20160321/</guid>
      <description>

&lt;h4 id=&#34;portal:a6d5e165e9b57a94b0d014e7e5e7a64d&#34;&gt;Portal&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Added the ability to create primary storage groups larger than 2TB when ordering.&lt;/li&gt;
&lt;li&gt;Resolved an issue that was preventing customers with Legacy (The Planet) subnets from viewing them in the customer portal.&lt;/li&gt;
&lt;li&gt;Fixed an issue with a very small subset of accounts which was causing the order forms not to load properly.&lt;/li&gt;
&lt;li&gt;Resolved an issue that was preventing customers from ordering static subnets routed to a Netscaler VPX.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;api:a6d5e165e9b57a94b0d014e7e5e7a64d&#34;&gt;API&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Account_MasterServiceAgreement/getPdf&#34;&gt;SoftLayer_Account_MasterServiceAgreement::getPdf&lt;/a&gt; is being deprecated. Please use &lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Account_MasterServiceAgreement/getFile&#34;&gt;SoftLayer_Account_MasterServiceAgreement::getFile&lt;/a&gt; going forward.&lt;/li&gt;
&lt;li&gt;Deprecated createDate and modifyDate on &lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Account_Regional_Registry_Detail_Type&#34;&gt;SoftLayer_Account_Regional_Registry_Detail_Type&lt;/a&gt; and &lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Account_Regional_Registry_Detail_Property_Type&#34;&gt;SoftLayer_Account_Regional_Registry_Detail_Property_Type&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;backend:a6d5e165e9b57a94b0d014e7e5e7a64d&#34;&gt;Backend&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Resolved an issue with VSI cancellations that were stalling due to the presence of duplicate category codes.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Backup and Restore firewall rules</title>
      <link>https://softlayer.github.io/python/manage_firewall_rules/</link>
      <pubDate>Mon, 07 Mar 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/manage_firewall_rules/</guid>
      <description>&lt;p&gt;restoreRules here will clobber any existing rules on the firewall, so be careful with that.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
import SoftLayer
from SoftLayer.CLI import firewall
from pprint import pprint as pp
import json
from argparse import ArgumentParser

class ruleSaver():

    def __init__(self, path, fw):
        self.client = SoftLayer.Client()
        self.fw = SoftLayer.FirewallManager(self.client)
        self.path = path
        self.fw_type, self.fw_id = firewall.parse_id(fw)

    def saveRules(self):
        if self.fw_type == &#39;vlan&#39;:
            rules = self.fw.get_dedicated_fwl_rules(self.fw_id)
        else:  
            rules = self.fw.get_standard_fwl_rules(self.fw_id)
        with open(self.path, &#39;w&#39;) as f:
            json.dump(rules,f)
        print(&amp;quot;Done saving rules to %s&amp;quot; % self.path)

    def restoreRules(self):
        with open(self.path, &#39;r&#39;) as f:
            rules = json.load(f)
        if self.fw_type == &#39;vlan&#39;:
            result = self.fw.edit_dedicated_fwl_rules(self.fw_id,rules)
        else:  
            result = self.fw.edit_standard_fwl_rules(self.fw_id,rules)
        return result

if __name__ == &amp;quot;__main__&amp;quot;:
    
    parser = ArgumentParser(description=&#39;Backup/Restore firewall rules&#39;)
    parser.add_argument(&#39;-f&#39;, nargs=1, type=str, required=True, metavar=&amp;quot;[/path/to/file]&amp;quot;, dest=&amp;quot;path&amp;quot;,
        help=&amp;quot;File to save to / restore from&amp;quot;)
    parser.add_argument(&#39;-i&#39;, nargs=1, type=str, required=True, metavar=&amp;quot;[type:id]&amp;quot;, dest=&amp;quot;fw&amp;quot;,
        help=&amp;quot;Firewall ID, same format as &#39;slcli firewall list&#39;. vlan:1234, vs:1234, sever:1234&amp;quot;)
    parser.add_argument(&#39;-a&#39;, nargs=1, type=str, required=True, metavar=&amp;quot;[save|restore]&amp;quot;, dest=&amp;quot;action&amp;quot;,
        help=&amp;quot;save to file, or restore from file. restore completely overwrites any existing rules&amp;quot;)

    args = parser.parse_args()
    main = ruleSaver(args.path[0],args.fw[0])
    action = args.action[0]

    if action == &#39;restore&#39;:
        result = main.restoreRules()
        pp(result)
    else:
        main.saveRules()

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Release notes: March 7, 2016</title>
      <link>https://softlayer.github.io/release_notes/20160307/</link>
      <pubDate>Mon, 07 Mar 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/release_notes/20160307/</guid>
      <description>

&lt;h4 id=&#34;portal:a6aad70dd740d62d762898eafdd2027f&#34;&gt;Portal&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Fixed an issue where some exception errors were not getting their messages properly translated, so the actual error message was being masked.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;api:a6aad70dd740d62d762898eafdd2027f&#34;&gt;API&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Resolved an issue that was causing a call to &lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Resource_Metadata/getBackendMacAddresses&#34;&gt;SoftLayer_Resource_Metadata::getBackendMacAddresses&lt;/a&gt; to return duplicate results.&lt;/li&gt;
&lt;li&gt;Resolved an issue that was preventing Sales quotes from being callable via the API.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;backend:a6aad70dd740d62d762898eafdd2027f&#34;&gt;Backend&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Customers with Private Host VSI&amp;rsquo;s can call to opt-out of host reboots for major maintenance events.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Attach and Detach a Block Device to a Virtual_Guest</title>
      <link>https://softlayer.github.io/python/attach_disk/</link>
      <pubDate>Thu, 03 Mar 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/attach_disk/</guid>
      <description>&lt;p&gt;Attaching a currently detached block device.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
import SoftLayer
from pprint import pprint as pp
client = SoftLayer.Client()

vsi_id = &#39;11111111&#39;
disk_id = &#39;8888888&#39;
attach = client[&#39;SoftLayer_Virtual_Guest&#39;].attachDiskImage(disk_id,id=vsi_id)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Detaching a currently attached block device.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
import SoftLayer
from pprint import pprint as pp
client = SoftLayer.Client()

vsi_id = &#39;11111111&#39;
disk_id = &#39;8888888&#39;
attach = client[&#39;SoftLayer_Virtual_Guest&#39;].detachDiskImage(disk_id,id=vsi_id)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Update Firmware on a Bare Metal Server</title>
      <link>https://softlayer.github.io/python/update_firmware/</link>
      <pubDate>Thu, 03 Mar 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/update_firmware/</guid>
      <description>&lt;p&gt;In the following example we are updating the firmware for the IPMI, BIOS, Hard Drives, and Raid Controller on our Bare Metal Server with ID 12345. We can toggle the specific items we want updated by setting the values to False (Do not update firmware) or True (Do update firmware).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
import SoftLayer
client = SoftLayer.Client()
mgr = SoftLayer.HardwareManager(client)

result = mgr.update_firmware(hardware_id=12345,ipmi=True,raid_controller=True,bios=True,hard_drive=True)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Manage Users</title>
      <link>https://softlayer.github.io/python/manageUsers/</link>
      <pubDate>Tue, 01 Mar 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/manageUsers/</guid>
      <description>&lt;p&gt;Creates a user, sets up proper permissions, sets up devices access restrictions, creates API keys and orders the user a server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import SoftLayer.API
from pprint import pprint as pp


def create_user(username, password):
    user_template = {
        &#39;username&#39;: username,
        &#39;firstName&#39;: &#39;API&#39;,
        &#39;lastName&#39;: &#39;Learner&#39;,
        &#39;email&#39;: &#39;someone@somewhere.com&#39;,
        &#39;companyName&#39;: &#39;IBM&#39;,
        &#39;address1&#39;: &#39;123 api road&#39;,
        &#39;city&#39;: &#39;Houston&#39;,
        &#39;country&#39;: &#39;US&#39;,
        &#39;postalCode&#39;: &#39;TX 77002&#39;,
        &#39;userStatusId&#39;: 1001,
        &#39;timezoneId&#39;: 107
    }
    created_user = client[&#39;User_Customer&#39;].createObject(
        user_template,
        password,
        password)
    return created_user

def get_permissions(_id):
    permissions = client[&#39;User_Customer&#39;].getPermissions(id=_id)
    return permissions

def set_permissions(_id, permissions):
    &amp;quot;&amp;quot;&amp;quot;
    To get permissions correct, I take the existing permissions of a user
    that I already have, and set my new user&#39;s permissions to be the same
    with addBulkPortalPermission
    &amp;quot;&amp;quot;&amp;quot;
    return client[&#39;User_Customer&#39;].addBulkPortalPermission(
        permissions, id=_id)

def fix_permissions(user,permissions):
    # I only want users to have access to this one host
    virtualGuestId = 22334455
    t = user[&#39;id&#39;]
    set_permissions(user[&#39;id&#39;], permissions)
    client[&#39;User_Customer&#39;].removeAllVirtualAccessForThisUser(id=t)
    client[&#39;User_Customer&#39;].removeAllHardwareAccessForThisUser(id=t)
    client[&#39;User_Customer&#39;].addApiAuthenticationKey(id=t)
    client[&#39;User_Customer&#39;].addVirtualGuestAccess(virtualGuestId,id=t)

def orderUserServer(user, apiKey):
    &amp;quot;&amp;quot;&amp;quot;
    Orders a server as the newly created user. 
    &amp;quot;&amp;quot;&amp;quot;
    hostname = user + &amp;quot;-lab-server&amp;quot;
    guest = {}
    guest[&#39;startCpus&#39;] = 1
    guest[&#39;maxMemory&#39;] = 1024
    guest[&#39;localDiskFlag&#39;] = False
    guest[&#39;hostname&#39;] = hostname
    guest[&#39;domain&#39;] = user + &amp;quot;.lablayer.info&amp;quot;
    guest[&#39;hourlyBillingFlag&#39;] = True
    guest[&#39;datacenter&#39;] = {}
    guest[&#39;datacenter&#39;][&#39;name&#39;] = &#39;tok02&#39;
    guest[&#39;blockDeviceTemplateGroup&#39;] = {&#39;globalIdentifier&#39;: &amp;quot;6c64f59a-edeb-4ba4-b992-d04972597357&amp;quot;}
    userClient = SoftLayer.Client(
        username = user,
        api_key = apiKey )
    result = userClient[&#39;Virtual_Guest&#39;].createObject(guest)
    print &amp;quot;Added server id: %s  ( %s )&amp;quot; % (result[&#39;id&#39;],result[&#39;fullyQualifiedDomainName&#39;]) 
    return
   

if __name__ == &amp;quot;__main__&amp;quot;:
    import argparse
    argsparse = argparse.ArgumentParser(description=&#39;Number of users&#39;)
    argsparse.add_argument(&#39;--num-users&#39;, dest=&#39;num_users&#39;, type=int,
                           help=&#39;Number of users to provision.&#39;)
    argsparse.add_argument(&#39;--offset&#39;, dest=&amp;quot;offset&amp;quot;, type=int,
                           default=1, help=&#39;Username offset&#39;)
    argsparse.add_argument(&#39;--prefix&#39;,
                           help=&#39;Username prefix&#39;, default=False)
    args = argsparse.parse_args()

    ##### CHANGE THESE ##########
    template_user_id = 123456
    password = &#39;APAsswordGoes!!!H3r3&#39; 

    client = SoftLayer.Client()
    
    userPerms = client[&#39;User_Customer&#39;].getPermissions(id=template_user_id)
   
    start_user_num = args.offset

    for i in range(args.num_users):
        target_username = &#39;%s-%s&#39; % (args.prefix,start_user_num)
        try:
            new_user = create_user(target_username,password)
            fix_permissions(new_user,userPerms)
            client[&#39;User_Customer&#39;].addApiAuthenticationKey(id=new_user[&#39;id&#39;])

        except SoftLayer.exceptions.SoftLayerAPIError as error:
            &amp;quot;&amp;quot;&amp;quot;
            If the user already exists, an exception is thrown. 
            Just reset their permissions and continue on.
            &amp;quot;&amp;quot;&amp;quot;
            oFilter = {}
            oFilter[&#39;users&#39;] = {}
            oFilter[&#39;users&#39;][&#39;username&#39;] = {}
            oFilter[&#39;users&#39;][&#39;username&#39;][&#39;operation&#39;] = target_username
            new_user = client[&#39;Account&#39;].getUsers(filter=oFilter)[0]
            fix_permissions(new_user,userPerms)

        newApiKey = client[&#39;User_Customer&#39;].getApiAuthenticationKeys(id=new_user[&#39;id&#39;])
        print &amp;quot;username = %s&amp;quot; % (newApiKey[0][&#39;user&#39;][&#39;username&#39;])
        print &amp;quot;api_key =  %s&amp;quot; % (newApiKey[0][&#39;authenticationKey&#39;])
        orderUserServer(newApiKey[0][&#39;user&#39;][&#39;username&#39;],newApiKey[0][&#39;authenticationKey&#39;])
        start_user_num = start_user_num + 1


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Disable user, changes their password, cancels their servers, and removes any sshKeys&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import SoftLayer.API
from pprint import pprint as pp

def get_target_users(prefix):
    _filter = {
        &#39;users&#39;: {
            &#39;username&#39;: {
                &#39;operation&#39;: &#39;*= %s&#39; % (prefix)
            }
        }
    }
    _mask = &amp;quot;mask[id,username]&amp;quot;
    _users = client[&#39;Account&#39;].getUsers(filter=_filter, mask=_mask)
    return _users

def get_target_keys(prefix):
    _filter = {
        &#39;sshKeys&#39;: {
            &#39;label&#39;: {
                &#39;operation&#39;: &#39;*= %s&#39; % (prefix)
            }
        }
    }

    _mask = &amp;quot;mask[id,label]&amp;quot;
    _users = client[&#39;Account&#39;].getSshKeys(filter=_filter, mask=_mask)
    return _users

def print_result(result, thing):
    if result == True:
        print &amp;quot;OK&amp;quot;
    else:
        print &amp;quot;ERROR: &amp;quot;
        pp(thing)
    return

if __name__ == &amp;quot;__main__&amp;quot;:
    import argparse
    argsparse = argparse.ArgumentParser(description=&#39;Number of users&#39;)
    argsparse.add_argument(&#39;--prefix&#39;,
                           help=&#39;Username prefix&#39;, default=False)
    argsparse.add_argument(&#39;--password&#39;,
                           help=&#39;New Password&#39;, default=False)
 
    args = argsparse.parse_args()

    client = SoftLayer.Client()
  
    users = get_target_users(args.prefix)

    for user in users:
        password =  args.password
        print &#39;User: &#39; + user[&#39;username&#39;] + &#39; Password: &#39; + password 
        # status 1021 disables the user
        template = {
            &#39;id&#39;: user[&#39;id&#39;],
            &#39;userStatusId&#39;: 1021
        }

        # Cancel any servers the user created
        servers = client[&#39;User_Customer&#39;].getVirtualGuests(id=user[&#39;id&#39;])
        result = True
        for virt in servers: 
            # the &amp;quot;,&amp;quot; and the end of print removes the automatic newline
            print(&amp;quot;\tCanceling host... &amp;quot; + virt[&#39;fullyQualifiedDomainName&#39;] + &amp;quot; (&amp;quot; + str(virt[&#39;id&#39;]) + &amp;quot;)\t&amp;quot;),
            try:
                result = client[&#39;Virtual_Guest&#39;].deleteObject(id=virt[&#39;id&#39;])
                print_result(result,virt)
            except SoftLayer.exceptions.SoftLayerAPIError as error:
                print(&amp;quot;\tException, host might already be canceling...&amp;quot;)
                pp(error)

        print(&amp;quot;\tChanging password for...&amp;quot; + user[&#39;username&#39;] + &amp;quot; (&amp;quot; + str(user[&#39;id&#39;]) + &amp;quot;)\t&amp;quot;),
        result = client[&#39;User_Customer&#39;].updatePassword(password, id=user[&#39;id&#39;])
        print_result(result,user)
 
    sshkeys = get_target_keys(args.prefix)
    print &#39;SSH Key Removal&#39;
    for key in sshkeys:
        print(&amp;quot;Deleting key... &amp;quot; + key[&#39;label&#39;] + &amp;quot; (&amp;quot; + str(key[&#39;id&#39;]) + &amp;quot;)\t&amp;quot;),
        result = client[&#39;SoftLayer_Security_Ssh_Key&#39;].deleteObject(id=key[&#39;id&#39;])
        print_result(result,key)

    print &#39;Complete&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Release notes: February 29, 2016</title>
      <link>https://softlayer.github.io/release_notes/20160229/</link>
      <pubDate>Mon, 29 Feb 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/release_notes/20160229/</guid>
      <description>

&lt;h4 id=&#34;portal:bc7b5768d66d4c7c293731ab8328c201&#34;&gt;Portal&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Resolved an issue that was causing Managed Hosting orders to reset when a Promo code was applied to an order.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;api:bc7b5768d66d4c7c293731ab8328c201&#34;&gt;API&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Removed defunct methods: &lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Metric_Tracking_Object/getBandwidthMinMax&#34;&gt;SoftLayer_Metric_Tracking_Object::getBandwidthMinMax&lt;/a&gt; and &lt;a href=&#34;http://sldn.softlayer.com/reference/services/SoftLayer_Virtual_Guest&#34;&gt;SoftLayer_Virtual_Guest&lt;/a&gt;::getBandwidthMinMax&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;backend:bc7b5768d66d4c7c293731ab8328c201&#34;&gt;Backend&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Resolved an issue that was causing RedHat licenses to be terminated upon an OS reload.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Get Notifications</title>
      <link>https://softlayer.github.io/python/notifications/</link>
      <pubDate>Fri, 26 Feb 2016 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>https://softlayer.github.io/python/notifications/</guid>
      <description>&lt;p&gt;Retrieves all notifications that were created on January 1, 2016.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import SoftLayer
from pprint import pprint as pp

class example():

    def __init__(self):

        self.client = SoftLayer.Client()

    def main(self):
        theDate = &#39;01/01/2016 01:00:00&#39;
        _filter = {
                &#39;startDate&#39;: { 
                    &#39;operation&#39;: &#39;greaterThanDate&#39;,
                    &#39;options&#39;: [
                        {&#39;name&#39;: &#39;date&#39;, &#39;value&#39;: [theDate]}
                    ]
                }
            }
        result = self.client[&#39;SoftLayer_Notification_Occurrence_Event&#39;].getAllObjects(filter=_filter)
        pp(result)

if __name__ == &amp;quot;__main__&amp;quot;:
    main = example()
    main.main()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>